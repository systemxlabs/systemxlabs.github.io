<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title></title>
	<link href="https://systemxlabs.github.io/atom.xml" rel="self" type="application/atom+xml"/>
  <link href="https://systemxlabs.github.io"/>
	<generator uri="https://www.getzola.org/">Zola</generator>
	<updated>2025-04-01T00:00:00+00:00</updated>
	<id>https://systemxlabs.github.io/atom.xml</id>
	<entry xml:lang="en">
		<title>开源 datafusion-remote-table 库：在远端数据库执行 SQL 查询</title>
		<published>2025-04-01T00:00:00+00:00</published>
		<updated>2025-04-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-remote-table-intro/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-remote-table-intro/</id>
		<content type="html">&lt;p&gt;分享下最近写的一个开源库 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;systemxlabs&#x2F;datafusion-remote-table&quot;&gt;datafusion-remote-table&lt;&#x2F;a&gt;，主要用于在远端数据库执行任意 SQL 查询并将结果流式传输作为 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&quot;&gt;DataFusion&lt;&#x2F;a&gt; 的 一张表（ Table Provider ）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;gong-neng&quot;&gt;功能&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;在远端数据库执行 SQL 查询并将结果流式传输到 DataFusion 作为一张表&lt;&#x2F;li&gt;
&lt;li&gt;支持下推 filters 和 limit 到远端数据库执行&lt;&#x2F;li&gt;
&lt;li&gt;执行算子可以序列化反序列化以支持分布式执行&lt;&#x2F;li&gt;
&lt;li&gt;数据可以被转换后再输出到下一算子&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-yong-fang-shi&quot;&gt;使用方式&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tokio&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt; async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; options &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;ConnectionOptions::Postgres(PostgresConnectionOptions::new(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;localhost&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;5432&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;user&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;password&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ));
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; remote_table &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;RemoteTable::try_new(options, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;select * from supported_data_types&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ctx &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;SessionContext::new();
&lt;&#x2F;span&gt;&lt;span&gt;    ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;register_table&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;remote_table&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, Arc::new(remote_table))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    ctx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;sql&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;select * from remote_table&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;show&lt;&#x2F;span&gt;&lt;span&gt;().await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;shi-yong-an-li&quot;&gt;使用案例&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;拉取远端数据源数据到本地，利用 datafusion 来进行高效的数据分析处理&lt;&#x2F;li&gt;
&lt;li&gt;读取远端数据源的系统表数据，例如表的字段信息&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;zhi-chi-shu-ju-ku&quot;&gt;支持数据库&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;Postgres
&lt;ul&gt;
&lt;li&gt;Int2 &#x2F; Int4 &#x2F; Int8&lt;&#x2F;li&gt;
&lt;li&gt;Float4 &#x2F; Float8 &#x2F; Numeric&lt;&#x2F;li&gt;
&lt;li&gt;Char &#x2F; Varchar &#x2F; Text &#x2F; Bpchar &#x2F; Bytea&lt;&#x2F;li&gt;
&lt;li&gt;Date &#x2F; Time &#x2F; Timestamp &#x2F; Timestamptz &#x2F; Interval&lt;&#x2F;li&gt;
&lt;li&gt;Bool &#x2F; Oid &#x2F; Name &#x2F; Json &#x2F; Jsonb &#x2F; Geometry(PostGIS)&lt;&#x2F;li&gt;
&lt;li&gt;Int2[] &#x2F; Int4[] &#x2F; Int8[]&lt;&#x2F;li&gt;
&lt;li&gt;Float4[] &#x2F; Float8[]&lt;&#x2F;li&gt;
&lt;li&gt;Char[] &#x2F; Varchar[] &#x2F; Bpchar[] &#x2F; Text[] &#x2F; Bytea[]&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;MySQL
&lt;ul&gt;
&lt;li&gt;TinyInt (Unsigned) &#x2F; Smallint (Unsigned) &#x2F; MediumInt (Unsigned) &#x2F; Int (Unsigned) &#x2F; Bigint (Unsigned)&lt;&#x2F;li&gt;
&lt;li&gt;Float &#x2F; Double &#x2F; Decimal&lt;&#x2F;li&gt;
&lt;li&gt;Date &#x2F; DateTime &#x2F; Time &#x2F; Timestamp &#x2F; Year&lt;&#x2F;li&gt;
&lt;li&gt;Char &#x2F; Varchar &#x2F; Binary &#x2F; Varbinary&lt;&#x2F;li&gt;
&lt;li&gt;TinyText &#x2F; Text &#x2F; MediumText &#x2F; LongText&lt;&#x2F;li&gt;
&lt;li&gt;TinyBlob &#x2F; Blob &#x2F; MediumBlob &#x2F; LongBlob&lt;&#x2F;li&gt;
&lt;li&gt;Json &#x2F; Geometry&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Oracle
&lt;ul&gt;
&lt;li&gt;Number &#x2F; BinaryFloat &#x2F; BinaryDouble &#x2F; Float&lt;&#x2F;li&gt;
&lt;li&gt;Varchar2 &#x2F; NVarchar2 &#x2F; Char &#x2F; NChar &#x2F; Long &#x2F; Clob &#x2F; NClob&lt;&#x2F;li&gt;
&lt;li&gt;Raw &#x2F; Long Raw &#x2F; Blob&lt;&#x2F;li&gt;
&lt;li&gt;Date &#x2F; Timestamp&lt;&#x2F;li&gt;
&lt;li&gt;Boolean&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;SQLite
&lt;ul&gt;
&lt;li&gt;Null &#x2F; Integer &#x2F; Real &#x2F; Text &#x2F; Blob&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Visitor 模式的两种不同实现分析</title>
		<published>2025-02-06T00:00:00+00:00</published>
		<updated>2025-02-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/visitor-pattern/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/visitor-pattern/</id>
		<content type="html">&lt;p&gt;Visitor 模式常用于 AST（抽象语法树）之类的树形结构的遍历和改写，例如遍历 SQL AST 以确定其将访问哪些表、对 AST 中某些表达式进行简化等等。&lt;&#x2F;p&gt;
&lt;p&gt;Visitor 模式通常提供一个 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait 和一个接收 Visitor 实例的 &lt;code&gt;walk&lt;&#x2F;code&gt; 函数或者方法，用户通过实现 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait 来定义自己的 Visitor，然后通过执行 &lt;code&gt;walk&lt;&#x2F;code&gt; 函数或者方法（会将自定义的 Visitor 实例传入）来对整个树形结构进行遍历。&lt;&#x2F;p&gt;
&lt;p&gt;Visitor 模式在 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;databendlabs&#x2F;databend&quot;&gt;databend&lt;&#x2F;a&gt;、&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;iceberg-rust&quot;&gt;iceberg-rust&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-sqlparser-rs&quot;&gt;datafusion-sqlparser-rs&lt;&#x2F;a&gt; 等项目中有着不同的实现方式，我们以 SQL AST 为例来分析几种不同的 Visitor 模式实现。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-xian-yi-shou-gong-shi-xian&quot;&gt;实现一：手工实现&lt;&#x2F;h2&gt;
&lt;p&gt;老版本的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;systemxlabs&#x2F;databend-parser&quot;&gt;databend&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;iceberg-rust&quot;&gt;iceberg-rust&lt;&#x2F;a&gt; 是采用手工实现，通过手写代码进行递归遍历，若 AST 中新增类型则需要手动添加新类型的递归逻辑。&lt;&#x2F;p&gt;
&lt;p&gt;老版本的 databend 和 iceberg-rust 的实现略有区别，主要在于递归逻辑的位置，一个是放在 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait 中，由用户来控制如何递归，更灵活也更繁琐，一个是放在 &lt;code&gt;walk&lt;&#x2F;code&gt; 函数中，递归逻辑已经提前写好，用户无需关心但不够灵活。&lt;&#x2F;p&gt;
&lt;p&gt;以老版本的 databend 为例&lt;&#x2F;p&gt;
&lt;p&gt;定义 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait（每新增一种表达式，就需要在 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait 中新增一种对应方法）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Visitor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_column_ref&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;database&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Identifier&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;table&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Identifier&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;column&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ColumnID,
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_is_null&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Expr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;not&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_in_list&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Expr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[Expr], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;not&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;定义 &lt;code&gt;walk&lt;&#x2F;code&gt; 函数（每新增一种表达式，就需要在 &lt;code&gt;walk&lt;&#x2F;code&gt; 函数中新增一个 match arm，&lt;code&gt;walk&lt;&#x2F;code&gt; 函数比较简单，无需处理递归逻辑）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk_expr&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;V: Visitor&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;visitor&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; V, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Expr) {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; expr {
&lt;&#x2F;span&gt;&lt;span&gt;        Expr::ColumnRef {
&lt;&#x2F;span&gt;&lt;span&gt;            database,
&lt;&#x2F;span&gt;&lt;span&gt;            table,
&lt;&#x2F;span&gt;&lt;span&gt;            column,
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_column_ref&lt;&#x2F;span&gt;&lt;span&gt;(database, table, column),
&lt;&#x2F;span&gt;&lt;span&gt;        Expr::IsNull { expr, not } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_is_null&lt;&#x2F;span&gt;&lt;span&gt;(expr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;not),
&lt;&#x2F;span&gt;&lt;span&gt;        Expr::InList {
&lt;&#x2F;span&gt;&lt;span&gt;            expr,
&lt;&#x2F;span&gt;&lt;span&gt;            list,
&lt;&#x2F;span&gt;&lt;span&gt;            not,
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt;&lt;&#x2F;span&gt;&lt;span&gt; visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_in_list&lt;&#x2F;span&gt;&lt;span&gt;(expr, list, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;not),
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户自定义 Visitor（自己处理递归）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ColumnCounter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Visitor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ColumnCounter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_column_ref&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Identifier&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Option&amp;lt;Identifier&amp;gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ColumnID) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_is_null&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Expr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;not&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk_expr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, expr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_in_list&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;expr&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Expr, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;list&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[Expr], &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;not&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk_expr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, expr)
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; expr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; list {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk_expr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, expr);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;shi-xian-er-dai-ma-sheng-cheng&quot;&gt;实现二：代码生成&lt;&#x2F;h2&gt;
&lt;p&gt;新版本的 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;databendlabs&#x2F;databend&quot;&gt;databend&lt;&#x2F;a&gt; （采用的是 &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;a&gt; 库）和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-sqlparser-rs&quot;&gt;datafusion-sqlparser-rs&lt;&#x2F;a&gt; 是采用代码生成实现，通过派生宏给每个类型（包括 AST 类型和标准库中的类型）生成 &lt;code&gt;walk&lt;&#x2F;code&gt; 方法，&lt;code&gt;walk&lt;&#x2F;code&gt; 方法会递归遍历其内部每个元素。&lt;&#x2F;p&gt;
&lt;p&gt;定义 &lt;code&gt;Walk&lt;&#x2F;code&gt; trait&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Walk {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;V: Visitor&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;visitor&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; V);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;利用派生宏给每个 AST 类型生成 &lt;code&gt;Walk&lt;&#x2F;code&gt; trait 实现&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Walk)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Expr {
&lt;&#x2F;span&gt;&lt;span&gt;    IsNull {
&lt;&#x2F;span&gt;&lt;span&gt;        expr: Box&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        not: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;生成代码&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Walk &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Expr {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;V: Visitor&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;visitor&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; V) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 对当前类型中的每个元素递归调用 walk 方法
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::IsNull { expr, not } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                expr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;                not.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;下一步就是如何在 walk 遍历过程中插入对 Visitor 的调用，这也是 &lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-sqlparser-rs&quot;&gt;datafusion-sqlparser-rs&lt;&#x2F;a&gt; 实现的区别之处。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;a&gt; 采用的方式是在所有 walk 地方插入对 Visitor 的调用，Visitor 通过动态类型 &lt;code&gt;std::any::Any&lt;&#x2F;code&gt; 接收并在运行时判断具体类型。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;a&gt; 的 &lt;code&gt;Visitor&lt;&#x2F;code&gt; trait 只有一个方法&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;Visitor {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;item&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Any, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;event&lt;&#x2F;span&gt;&lt;span&gt;: Event);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Event {
&lt;&#x2F;span&gt;&lt;span&gt;    Enter,
&lt;&#x2F;span&gt;&lt;span&gt;    Exit,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;derive-visitor&quot;&gt;derive-visitor&lt;&#x2F;a&gt; 的派生宏生成代码&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Walk &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Expr {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;V: Visitor&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;visitor&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; V) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; walk 前插入对 Visitor 的调用
&lt;&#x2F;span&gt;&lt;span&gt;        visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, Event::Enter);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::IsNull { expr, not } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                expr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;                not.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; walk 后插入对 Visitor 的调用
&lt;&#x2F;span&gt;&lt;span&gt;        visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, Event::Exit);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户在实现自己的 Visitor 时，需要手动判断 &lt;code&gt;std::any::Any&lt;&#x2F;code&gt; 的具体类型&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ColumnCounter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;count&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Visitor &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;ColumnCounter {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;item&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Any, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;event&lt;&#x2F;span&gt;&lt;span&gt;: Event) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 通过 Any 的 downcast 方法判断具体类型
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if let &lt;&#x2F;span&gt;&lt;span&gt;Some(item) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;dyn ::std::any::Any&amp;gt;::downcast_ref::&amp;lt;ColumnRef&amp;gt;(item) {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; event {
&lt;&#x2F;span&gt;&lt;span&gt;                Event::Enter &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;; }
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;datafusion-sqlparser-rs&quot;&gt;datafusion-sqlparser-rs&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-sqlparser-rs&quot;&gt;datafusion-sqlparser-rs&lt;&#x2F;a&gt; 采用的方式是通过属性宏指定在某些 walk 地方插入对 Visitor 的调用。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Walk)]
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(with &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;visit_expr&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;Expr { &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;... &lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;生成代码&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Walk &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;Expr {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;V: Visitor&amp;gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;visitor&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; V) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; walk 前插入对 Visitor 的调用
&lt;&#x2F;span&gt;&lt;span&gt;        visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;pre_visit_expr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;::IsNull { expr, not } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                expr.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;                not.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;walk&lt;&#x2F;span&gt;&lt;span&gt;(visitor);
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_ =&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; walk 后插入对 Visitor 的调用
&lt;&#x2F;span&gt;&lt;span&gt;        visitor.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;post_visit_expr&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DataFusion 查询引擎 Hash Join</title>
		<published>2025-01-13T00:00:00+00:00</published>
		<updated>2025-01-13T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-hash-join/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-hash-join/</id>
		<content type="html">&lt;p&gt;对于含有等值连接条件的 Join，可以采用 Hash Join 方式进行加速计算，它利用了哈希表的查询特性，其本身也可以更好的并行化。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-jing&quot;&gt;场景&lt;&#x2F;h2&gt;
&lt;p&gt;主要用于 On 子句中含有等值连接条件的 Join 运算。例如默认用户配置下：表 &lt;code&gt;t0(a int, b int)&lt;&#x2F;code&gt; 和 &lt;code&gt;t1(c int, d int)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a = t1.c&lt;&#x2F;code&gt; 有一个 On 条件且是等值条件，走 Hash Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a &amp;gt; t1.c&lt;&#x2F;code&gt; 有一个 On 条件但非等值条件，走 Nested Loop Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a &amp;gt; t1.c and t0.b = t1.d&lt;&#x2F;code&gt; 有多个 On 条件且其中包含等值条件，走 Hash Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a = t1.c or t0.b &amp;gt; t1.d&lt;&#x2F;code&gt; 有多个 On 条件且其中包含等值条件，但是是“或”的关系，走 Nested Loop Join 算子&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;zhi-xing-mo-shi&quot;&gt;执行模式&lt;&#x2F;h2&gt;
&lt;p&gt;Hash Join 有两种执行模式：CollectLeft 和 Partitioned&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;CollectLeft 模式更加通用，会先将左表数据全部读取出来构建哈希表（被所有线程共享），然后跟右表 join&lt;&#x2F;li&gt;
&lt;li&gt;Partitioned 模式并行度更高，但要求左右表的 partition 数量相同并且分区方式都是以等值连接条件中的表达式进行哈希分区（例如 &lt;code&gt;on t0.a = t1.c&lt;&#x2F;code&gt;，左表需要按照 &lt;code&gt;t0.a&lt;&#x2F;code&gt; 进行哈希分区，右表需要按照 &lt;code&gt;t1.c&lt;&#x2F;code&gt; 进行哈希分区），它只需将左右表对应 partition 数据进行 join，无需构建一个全局的哈希表
&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-hash-join&#x2F;.&#x2F;datafusion-hash-join-partitioned-stream.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Partitioned 模式下左右表数据的分布&lt;&#x2F;strong&gt;：左右表中具有相同 join keys（等值） 的行一定被分布到左右对应相同的 partition 中（例如左右表中 join key 值为 2 的行均被分布到各自的 1 号 partition 中）。
&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-hash-join&#x2F;.&#x2F;datafusion-hash-join-data-distribution.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;执行模式选择策略：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;当用户希望并行度为 1 时，会采用 CollectLeft 模式&lt;&#x2F;li&gt;
&lt;li&gt;当用户不希望运行时收集统计数据时，默认走 Partitioned 模式&lt;&#x2F;li&gt;
&lt;li&gt;通过统计数据来选择执行模式，如果左右表数据量至少有一个比较小，则走 CollectLeft 模式，否则走 Partitioned 模式&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;you-hua&quot;&gt;优化&lt;&#x2F;h2&gt;
&lt;p&gt;Hash Join 主要参与以下优化&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;projection push down：优化器会尝试将 projection 下推到 Hash Join 算子的输入，如果无法下推，会尝试将 projection 嵌入到 Hash Join 算子中
&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-hash-join&#x2F;.&#x2F;datafusion-projection-pushdown-for-hash-join.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;li&gt;
&lt;li&gt;enforce distribution
&lt;ul&gt;
&lt;li&gt;对于 CollectLeft 模式，在左表上插入 Coalesce Partitions &#x2F; Sort Preserving Merge 算子，将其所有 partition 合并成 1 个&lt;&#x2F;li&gt;
&lt;li&gt;对于 Partitioned 模式，在左右表上插入 Repartition 算子，将其分区方式改成按等值连接条件哈希分区&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;join selection
&lt;ul&gt;
&lt;li&gt;优化器会根据 join 两边输入的统计信息，将小表放到左侧，大表放到右侧&lt;&#x2F;li&gt;
&lt;li&gt;如果左右输入均为无界且增量的（增量的意思是例如 filter 这种接收一批处理一批），则转换为 Symmetric Hash Join&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;zhi-xing&quot;&gt;执行&lt;&#x2F;h2&gt;
&lt;p&gt;以 Partitioned 模式为例，SQL 为 &lt;code&gt;select * from t0 full join t1 on t0.a = t1.c and t0.b &amp;gt; t1.d&lt;&#x2F;code&gt;，左右表的每个 partition 都会经历如下阶段，以第 0 号 partition 为例&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-yi-jie-duan-build-jie-duan&quot;&gt;第一阶段：build 阶段&lt;&#x2F;h3&gt;
&lt;p&gt;对左表的 partition0 所有数据构建哈希表，其中 key 为 &lt;code&gt;t0.a&lt;&#x2F;code&gt; 列值的哈希值，value 为行索引（这里会处理哈希冲突情况）。&lt;&#x2F;p&gt;
&lt;p&gt;例如左表 partition0 数据如下&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;行索引&lt;&#x2F;th&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t0.b&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;di-er-jie-duan-probe-jie-duan&quot;&gt;第二阶段：probe 阶段&lt;&#x2F;h3&gt;
&lt;p&gt;probe 阶段不断读取右表 partition0 的数据，与左表 partition0 数据进行 join。&lt;&#x2F;p&gt;
&lt;p&gt;第一步，从右表读取一批数据，计算这一批数据 &lt;code&gt;t1.c&lt;&#x2F;code&gt; 列值的哈希值&lt;&#x2F;p&gt;
&lt;p&gt;例如右表这一批数据如下&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;行索引&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;th&gt;t1.d&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第二步，使用第一步中计算的哈希值，从 build 阶段构建的左表的哈希表中查找满足等值连接条件 &lt;code&gt;t0.a = t1.c&lt;&#x2F;code&gt; 的行索引，然后根据行索引来比较 &lt;code&gt;t0.a&lt;&#x2F;code&gt; 列与 &lt;code&gt;t1.c&lt;&#x2F;code&gt; 列是否真的相等&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第三步，使用非等值连接条件 &lt;code&gt;t0.b &amp;gt; t1.d&lt;&#x2F;code&gt; 进行过滤&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第四步，根据 join 类型调整行索引&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果是 inner join，则不调整&lt;&#x2F;li&gt;
&lt;li&gt;如果是 left join，在第三阶段输出未匹配的左表数据&lt;&#x2F;li&gt;
&lt;li&gt;如果是 right join，则追加右表未匹配的行&lt;&#x2F;li&gt;
&lt;li&gt;如果是 full join，跟 right join 类似，不过还会在第三阶段输出未匹配的左表数据&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第五步，根据行索引结合 projection 输出 join 结果&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t0.b&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;th&gt;t0.d&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;di-san-jie-duan-shu-chu-zuo-biao-wei-pi-pei-de-xing&quot;&gt;第三阶段：输出左表未匹配的行&lt;&#x2F;h3&gt;
&lt;p&gt;构建行索引（左表第 2 已匹配，还剩第 0 和第 1 行未匹配）&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;根据行索引结合 projection 输出 join 结果&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t0.b&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;th&gt;t0.d&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;所以整个 SQL 的最终执行结果是&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t0.b&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;th&gt;t0.d&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;3&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;ha-xi-biao-she-ji&quot;&gt;哈希表设计&lt;&#x2F;h2&gt;
&lt;p&gt;当前 DataFusion 采用的哈希表设计是基于 &lt;code&gt;hashbrown::RawTable&lt;&#x2F;code&gt;（Google &lt;a href=&quot;https:&#x2F;&#x2F;abseil.io&#x2F;blog&#x2F;20180927-swisstables&quot;&gt;SwissTable&lt;&#x2F;a&gt; 的 Rust 实现） 和 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt;，自己计算哈希值和解决哈希冲突，&lt;code&gt;RawTable&lt;&#x2F;code&gt; 存放无冲突的哈希值到行索引映射，&lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; 存放哈希冲突的映射。哈希表的内存是一次性分配好，后续不会扩容（使用 &lt;code&gt;with_capacity&lt;&#x2F;code&gt; 创建来保证）。&lt;&#x2F;p&gt;
&lt;p&gt;假设左表的数据共有 10 行，在建立哈希表时，会分配一个容量为 10 的 &lt;code&gt;RawTable&lt;&#x2F;code&gt; 和 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;以下是插入过程。由于 0 被用作默认值，所以存放行索引时采用 +1 存储。当遇到哈希冲突时，会将原 &lt;code&gt;RawTable&lt;&#x2F;code&gt; 中的 value 存入到 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; 中，放置到行索引指向的地方。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-hash-join&#x2F;.&#x2F;datafusion-hash-join-hashmap.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在检索时，例如查找 hash 值为 10 的所有行索引&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;从 &lt;code&gt;RawTable&lt;&#x2F;code&gt; 中找到 key 为 10 的映射，即 &lt;code&gt;10 -&amp;gt; 5&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;使用上面拿到的 5（实际行索引为 4）从 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; 拿到 &lt;code&gt;3&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;使用上面拿到的 3（实际行索引为 2）从 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; 拿到 &lt;code&gt;1&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;使用上面拿到的 1（实际行索引为 0）从 &lt;code&gt;Vec&amp;lt;u64&amp;gt;&lt;&#x2F;code&gt; 拿到 &lt;code&gt;0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;由于上面拿到的值为 0，停止检索&lt;&#x2F;li&gt;
&lt;li&gt;最终检索到的结果是 &lt;code&gt;5, 3, 1&lt;&#x2F;code&gt;，因此实际行索引结果是 &lt;code&gt;4, 2, 0&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;保持输出顺序和输入顺序一致&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以上例子中输入的顺序是 &lt;code&gt;0, 2, 4&lt;&#x2F;code&gt;，而哈希检索结果中的顺序是 &lt;code&gt;4, 2, 0&lt;&#x2F;code&gt;。因此为了保持顺序一致，在构建哈希表时，DataFusion 会对输入数据进行翻转。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DataFusion 查询引擎 Nested Loop Join</title>
		<published>2025-01-06T00:00:00+00:00</published>
		<updated>2025-01-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-nested-loop-join/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-nested-loop-join/</id>
		<content type="html">&lt;p&gt;Nested Loop Join 是最通用的一种 join 实现，原理简单，实现容易。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chang-jing&quot;&gt;场景&lt;&#x2F;h2&gt;
&lt;p&gt;主要用于 On 子句中没有等值连接条件的 Join 运算。
例如：表 &lt;code&gt;t0(a int, b int)&lt;&#x2F;code&gt; 和 &lt;code&gt;t1(c int, d int)&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a &amp;gt; t1.c&lt;&#x2F;code&gt; 有 On 连接条件但非等值条件，走 Nested Loop Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1&lt;&#x2F;code&gt; 没有任何连接条件且是 inner join，走 Cross Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 left join t1&lt;&#x2F;code&gt; 没有任何连接条件，非 inner join，走 Nested Loop Join 算子&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;select * from t0 join t1 on t0.a &amp;gt; t1.c and t0.b = t1.d&lt;&#x2F;code&gt; 有 On 连接条件且其中包含等值条件，走 Hash Join 或 Sort Merge Join 算子（根据用户配置）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;you-hua&quot;&gt;优化&lt;&#x2F;h2&gt;
&lt;p&gt;Nested Loop Join 会参与两个物理阶段优化&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;projection push down：优化器会尝试将 projection 下推到 Nested Loop Join 算子的输入，如果无法下推，会尝试将 projection 嵌入到 Nested Loop Join 算子中&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-nested-loop-join&#x2F;.&#x2F;datafusion-projection-pushdown-for-nlj.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;join selection：优化器会根据 join 两边输入的统计信息，将小表放到左侧，大表放到右侧&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;zhi-xing&quot;&gt;执行&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;di-yi-jie-duan-build-jie-duan&quot;&gt;第一阶段：build 阶段&lt;&#x2F;h3&gt;
&lt;p&gt;读取左表所有 partition 的数据到内存中，被所有线程共享。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-er-jie-duan-probe-jie-duan&quot;&gt;第二阶段：probe 阶段&lt;&#x2F;h3&gt;
&lt;p&gt;probe 阶段是分 partition 并行执行的，每个线程不断读取对应 partition 的右表数据，与左表数据进行 join。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-nested-loop-join&#x2F;.&#x2F;datafusion-nlj-partitioned-stream.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以如下数据为例，SQL 为 &lt;code&gt;select t0.a, t1.c from t0 full join t1 on t0.a &amp;gt; t1.c&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-nested-loop-join&#x2F;.&#x2F;datafusion-nlj-example-data.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;第一步，先构建两个表的行索引的笛卡尔积&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第二步，应用 On 条件过滤行索引&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第三步，根据 join 类型调整行索引&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果是 inner join，则不调整&lt;&#x2F;li&gt;
&lt;li&gt;如果是 left join，在第三阶段输出未匹配的左表数据&lt;&#x2F;li&gt;
&lt;li&gt;如果是 right join，则追加右表未匹配的行&lt;&#x2F;li&gt;
&lt;li&gt;如果是 full join，跟 right join 类似，不过还会在第三阶段输出未匹配的左表数据&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;0&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;第四步，根据行索引结合 projection 输出 join 结果。例如 full join，会输出&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;di-san-jie-duan-shu-chu-zuo-biao-wei-pi-pei-de-xing&quot;&gt;第三阶段：输出左表未匹配的行&lt;&#x2F;h3&gt;
&lt;p&gt;构建行索引（左表第 0 和 第 1 行已匹配，还剩第 2 行未匹配）&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;左表行索引&lt;&#x2F;th&gt;&lt;th&gt;右表行索引&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;根据行索引结合 projection 输出 join 结果&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;所以 &lt;code&gt;select t0.a, t1.c from t0 full join t1 on t0.a &amp;gt; t1.c&lt;&#x2F;code&gt; 的最终执行结果是&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;t0.a&lt;&#x2F;th&gt;&lt;th&gt;t1.c&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;5&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;2&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;9&lt;&#x2F;td&gt;&lt;td&gt;6&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;td&gt;10&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;NULL&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Rust 异步运行时 smol 剖析</title>
		<published>2024-12-09T00:00:00+00:00</published>
		<updated>2024-12-09T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/smol-async-runtime/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/smol-async-runtime/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;smol&quot;&gt;smol&lt;&#x2F;a&gt; 是一个小型且快速的 Rust 异步运行时，它由许多小型的 crate 组成（比如 polling &#x2F; async-io &#x2F; async-executor 等），每个 crate 相对独立，非常适合学习 Rust 异步运行时是如何一步步构建的。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;crates-gai-lan&quot;&gt;crates 概览&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;smol-async-runtime&#x2F;.&#x2F;smol-crates-overview.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;核心基础库&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;polling&quot;&gt;polling&lt;&#x2F;a&gt; 提供一个在 epoll &#x2F; kqueue &#x2F; iocp 等之上统一的 IO 多路复用的接口&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-io&quot;&gt;async-io&lt;&#x2F;a&gt; 实现 reactor 和 driver 底层机制并对外提供 &lt;code&gt;Async&lt;&#x2F;code&gt; 和 &lt;code&gt;Timer&lt;&#x2F;code&gt; 两个工具来实现异步 IO 和定时器&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;blocking&quot;&gt;blocking&lt;&#x2F;a&gt; 提供用于在异步环境中隔离同步 IO 操作的线程池&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-task&quot;&gt;async-task&lt;&#x2F;a&gt; 提供异步任务的抽象封装，便于构建自己的 executor&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;面向用户的上层库&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-net&quot;&gt;async-net&lt;&#x2F;a&gt; 基于 async-io 的 Async 工具对标准库 &lt;code&gt;std::net&lt;&#x2F;code&gt; 的封装&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-process&quot;&gt;async-process&lt;&#x2F;a&gt; 基于 async-io（Unix-like 系统）和 blocking（Windows 系统）对标准库 &lt;code&gt;std::process&lt;&#x2F;code&gt; 的封装&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-fs&quot;&gt;async-fs&lt;&#x2F;a&gt; 基于 blocking 对标准库 &lt;code&gt;std::fs&lt;&#x2F;code&gt; 的封装&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-executor&quot;&gt;async-executor&lt;&#x2F;a&gt; 提供单线程和多线程两种 executor&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;工具库&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-channel&quot;&gt;async-channel&lt;&#x2F;a&gt; 提供异步的多生产者多消费者队列&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;smol-rs&#x2F;async-lock&quot;&gt;async-lock&lt;&#x2F;a&gt; 提供异步环境的同步原语，如互斥锁、读写锁等等&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;本文主要学习 polling &#x2F; async-io &#x2F; async-task &#x2F; async-executor 库，理解最重要的 IO 多路复用 &#x2F; reactor &#x2F; driver &#x2F; task &#x2F; executor 等概念。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;polling&quot;&gt;polling&lt;&#x2F;h2&gt;
&lt;p&gt;polling 对 epoll &#x2F; kqueue &#x2F; iocp 等各平台的 IO 多路复用机制进行了一个统一的抽象，方便跨平台使用。&lt;&#x2F;p&gt;
&lt;p&gt;它提供了一个 &lt;code&gt;Poller&lt;&#x2F;code&gt; 结构体，封装了各平台的 IO 多路复用机制（例如 Linux 下则包含 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_create.2.html&quot;&gt;epoll_create1&lt;&#x2F;a&gt; 返回的文件描述符），并主要提供了三个方法&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;增删改感兴趣的 IO 事件（参考 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_ctl.2.html&quot;&gt;epoll_ctl&lt;&#x2F;a&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;阻塞等待新的 IO 事件（参考 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_wait.2.html&quot;&gt;epoll_wait&lt;&#x2F;a&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;唤醒正在阻塞等待中的自身&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;以 Linux 下 epoll 为例分析其细节，&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;创建 Poller 时，调用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_create.2.html&quot;&gt;epoll_create1&lt;&#x2F;a&gt; 创建一个新的 epoll 实例并保存到 Poller 中，同时往 epoll 列表中注册两个 IO 源
&lt;ul&gt;
&lt;li&gt;调用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;eventfd.2.html&quot;&gt;eventfd&lt;&#x2F;a&gt; 创建用于通知（唤醒）的对象 notifier&lt;&#x2F;li&gt;
&lt;li&gt;调用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;timerfd_create.2.html&quot;&gt;timerfd_create&lt;&#x2F;a&gt; 创建的定时器&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;增删改感兴趣的 IO 事件时，传入其所属的文件描述符（例如 socket），关联数据（当返回 IO 事件时携带），以及一些标志位（比如只监听可读或可写事件）&lt;&#x2F;li&gt;
&lt;li&gt;阻塞等待新的 IO 事件时，可传入超时时间，当有新的 IO 事件（一个或多个） &#x2F; 中断 &#x2F; 超时，结束阻塞返回。这里并没有使用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_wait.2.html&quot;&gt;epoll_wait&lt;&#x2F;a&gt; 本身的超时机制，而是使用更为精确的定时器，在调用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;epoll_wait.2.html&quot;&gt;epoll_wait&lt;&#x2F;a&gt; 前会通过 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;timerfd_settime.2.html&quot;&gt;timerfd_settime&lt;&#x2F;a&gt; 设置定时器超时时间，当超时时间到达时，会在 timer 文件描述符上产生一个新的 IO 事件来结束阻塞&lt;&#x2F;li&gt;
&lt;li&gt;唤醒正在阻塞等待中的自身时，通过调用 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;write.2.html&quot;&gt;write&lt;&#x2F;a&gt; 往 notifier 文件描述符上写入数据来触发一个新的 IO 事件来结束阻塞&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;具体例子&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 创建一个 socket
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; socket &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;TcpListener::bind(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;127.0.0.1:8000&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;socket.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;set_nonblocking&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 指定 socket 标识符（epoll 返回新的 IO 事件时会携带）
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; key &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 创建一个 epoll 实例，并执行初始化工作（注册 notifier 和 timer 到 epoll 列表中）
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; poller &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Poller::new()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 将 socket 添加到 epoll 队列中，监听其可读事件
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    poller.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;socket, Event::readable(key))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; events &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Events::new();
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;    events.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;clear&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 阻塞等待新的 IO 事件（这里并未传入超时时间）
&lt;&#x2F;span&gt;&lt;span&gt;    poller.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;wait&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; events, None)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; ev &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;in&lt;&#x2F;span&gt;&lt;span&gt; events.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 如果发现 socket 可读事件，则执行下一步操作
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; ev.key &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;==&lt;&#x2F;span&gt;&lt;span&gt; key {
&lt;&#x2F;span&gt;&lt;span&gt;            socket.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;accept&lt;&#x2F;span&gt;&lt;span&gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 继续监听 socket 可读事件
&lt;&#x2F;span&gt;&lt;span&gt;            poller.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;modify&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;socket, Event::readable(key))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 在 socket drop 前必须要将其从 epoll 列表中移除
&lt;&#x2F;span&gt;&lt;span&gt;poller.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;delete&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;socket)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;async-io&quot;&gt;async-io&lt;&#x2F;h2&gt;
&lt;p&gt;async-io 提供了一个全局唯一的 Reactor 实例来支持对定时器 Timer 和 IO 对象的事件监听，它利用了 polling 提供的 IO 多路复用抽象。Reactor 并不会主动去轮询监听新事件，而是需要一个 Driver 来进行驱动，Driver 实际上就是一个独立的 OS 线程，它会一直循环不断的驱动 Reactor。&lt;&#x2F;p&gt;
&lt;p&gt;在 Reactor 之上提供了两个面向用户的工具：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Async：用于构建异步 IO 的适配器，用户使用它来包装同步 IO 类型（如 &lt;code&gt;std::net::TcpStream&lt;&#x2F;code&gt;），然后提供异步的 IO 读写能力&lt;&#x2F;li&gt;
&lt;li&gt;Timer: 用户可以创建一个 Timer 来周期性的发出事件，Timer 实现了 &lt;code&gt;Future&lt;&#x2F;code&gt; 和 &lt;code&gt;Stream&lt;&#x2F;code&gt; trait，用户可以对它进行 &lt;code&gt;poll&lt;&#x2F;code&gt; 或 &lt;code&gt;poll_next&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Reactor&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Reactor 提供了 &lt;code&gt;insert_io&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;remove_io&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;insert_timer&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;remove_timer&lt;&#x2F;code&gt; 方法来向 Reactor （取消）注册 IO 对象或者定时器，对于 IO 对象，会（取消）注册到底层 OS 的 IO 多路复用机制上（如 epoll）。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; IO 源
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;derive&lt;&#x2F;span&gt;&lt;span&gt;(Debug)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Source {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; IO 文件描述符
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;registration&lt;&#x2F;span&gt;&lt;span&gt;: Registration,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; IO 源的 ID，注册到 epoll 时携带，用它来区分 IO 事件来自哪个 IO 源
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;key&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; IO 源的读端和写端的状态，和监听它的 wakers
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;[Direction; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Reactor 将 IO 源封装为一个 &lt;code&gt;Source&lt;&#x2F;code&gt; 结构，上层持有 &lt;code&gt;Source&lt;&#x2F;code&gt; 可以进行 poll，如果 IO 源 ready 则返回 &lt;code&gt;Poll::Ready&lt;&#x2F;code&gt;，否则 Reactor 会保存 waker 并返回 &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;。一个 IO 源可以被多个 wakers 来监听。&lt;&#x2F;p&gt;
&lt;p&gt;Reactor 的核心是 &lt;code&gt;fn react(&amp;amp;mut self, timeout: Option&amp;lt;Duration&amp;gt;) -&amp;gt; io::Result&amp;lt;()&amp;gt;&lt;&#x2F;code&gt; 方法，它会阻塞线程直到有新的 IO &#x2F; timer 事件（如果传入了超时时间则可能超时返回），当收到新的事件后，通过 poll 传递下来的 waker 来进行唤醒。它通过 Mutex 被限制为只能有一个线程来执行，无法并发执行。&lt;&#x2F;p&gt;
&lt;p&gt;Reactor 通过 tick 机制来保证 IO 事件是否是“新鲜的”，在每轮 &lt;code&gt;react&lt;&#x2F;code&gt; 方法执行期间，tick 值都会自增 1。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Driver&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因为 epoll 的模型就是需要用户去轮询，它不会主动推送 IO 事件，所以我们需要 Driver 来驱动。Driver 是一个单独的 OS 线程，在 Reactor 初始化时一并创建。它不断循环的去尝试获取 Reactor 锁并执行其 &lt;code&gt;react&lt;&#x2F;code&gt; 方法，然后 &lt;code&gt;react&lt;&#x2F;code&gt; 方法会阻塞 Driver 线程直至有新的 timer &#x2F; IO 事件产生。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Async&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Async 的原理是通过异步机制监控 IO 源是否 ready，对其进行 poll 的结果是 IO 源是否可读或可写，而不是读取或写入数据到 IO 源。所以当我们需要执行同步 IO 操作时，先让 Async 监控 IO 源是否 ready，当 IO 源 ready 了再执行同步 IO 操作，这时就不会发生 IO 阻塞线程了。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;my_server&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; std::io::Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; listener &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Async::new(std::net::TcpListener::bind(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;127.0.0.1:8080&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(_stream, addr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; listener.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;read_with&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;io&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;std::net::TcpListener| io.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;accept&lt;&#x2F;span&gt;&lt;span&gt;()).await&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Accepted connection from: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, addr);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;以上示例创建了一个同步的 &lt;code&gt;std::net::TcpListener&lt;&#x2F;code&gt; 并用 Async 包装起来，然后就可以异步地监听新连接。其过程是&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;std::net::TcpListener&lt;&#x2F;code&gt; 实现了 &lt;code&gt;AsFd&lt;&#x2F;code&gt; trait，Async 获取其 IO 文件描述符&lt;&#x2F;li&gt;
&lt;li&gt;通过 &lt;a href=&quot;https:&#x2F;&#x2F;man7.org&#x2F;linux&#x2F;man-pages&#x2F;man2&#x2F;fcntl.2.html&quot;&gt;fcntl&lt;&#x2F;a&gt; 系统调用将其设置为非阻塞 IO&lt;&#x2F;li&gt;
&lt;li&gt;然后 IO 对象注册到 Reactor 中，获取其 &lt;code&gt;Source&lt;&#x2F;code&gt; 引用&lt;&#x2F;li&gt;
&lt;li&gt;在 Async 被 poll 时，会通过其内部持有的 &lt;code&gt;Source&lt;&#x2F;code&gt; 来执行 poll，此时 IO 源未 ready，则 Reactor 会保存其 waker，返回 &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;等到有新的 IO 事件时，Reactor 再通过 waker 通知&lt;&#x2F;li&gt;
&lt;li&gt;Async 被再次 poll，此时 IO 源 ready，返回 &lt;code&gt;Poll::Ready(Ok(()))&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;然后再执行 &lt;code&gt;std::net::TcpListener::accept&lt;&#x2F;code&gt; 同步方法，此时执行 accept 不会阻塞，而是会立刻返回&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;async-task&quot;&gt;async-task&lt;&#x2F;h2&gt;
&lt;p&gt;async-task 提供了异步任务的抽象封装，异步任务 RawTask 包含 future 以及 future 运行时所需的内容，基于 RawTask 对外提供了两个安全的封装 Runnable 和 Task。Runnable 主要给上层 Executor 使用，Executor 可以使用 Runnable 触发一次调度或者执行一次 poll。Task 主要面向用户使用，用户可以 await Task，也可以取消 Task 或者让 Task 后台运行。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;smol-async-runtime&#x2F;.&#x2F;async-task-layout.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以上是 RawTask 的内存布局，包含：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;state&lt;&#x2F;code&gt;: 任务状态&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;awaiter&lt;&#x2F;code&gt;: 用户 poll Task 时注册的 waker&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;vtable&lt;&#x2F;code&gt;: 指向一个静态变量，包含各种函数指针
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;schedule&lt;&#x2F;code&gt;: 实际会调用 custom_schedule&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;drop_future&lt;&#x2F;code&gt;: 析构 future&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;get_output&lt;&#x2F;code&gt;: 读取 future 结果&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;drop_ref&lt;&#x2F;code&gt;: 减少任务引用计数，当引用计数归零时，调用 destroy 销毁任务&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;destroy&lt;&#x2F;code&gt;: 清理任务的资源和内存&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;run&lt;&#x2F;code&gt;: 执行异步任务&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;clone_waker&lt;&#x2F;code&gt;: 克隆一个新的 waker&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;metadata&lt;&#x2F;code&gt;: Executor 传入的自定义数据&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;custom_schedule&lt;&#x2F;code&gt;: Executor 传入的调度方法，RawTask 使用它来向 Executor 触发一次调度&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;future&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;output&lt;&#x2F;code&gt;: 一块 union 区域，存放 future 或者其结果 output&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;其中 &lt;code&gt;clone_waker&lt;&#x2F;code&gt;、&lt;code&gt;wake&lt;&#x2F;code&gt;、&lt;code&gt;wake_by_ref&lt;&#x2F;code&gt; 和 &lt;code&gt;drop_waker&lt;&#x2F;code&gt; 组成了标准库 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;task&#x2F;struct.RawWakerVTable.html&quot;&gt;RawWakerVTable&lt;&#x2F;a&gt; 的四个方法。&lt;&#x2F;p&gt;
&lt;p&gt;RawTask 内包含一套引用计数机制，Runnable、Task 和 Waker 都持有对 RawTask 的引用，当引用计数归零时，就会执行 &lt;code&gt;destroy&lt;&#x2F;code&gt; 方法清理 RawTask 资源和内存。&lt;&#x2F;p&gt;
&lt;p&gt;任务主要有以下状态：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;scheduled&lt;&#x2F;code&gt;: 即将被调度执行&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;running&lt;&#x2F;code&gt;: 正在执行 poll&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;completed&lt;&#x2F;code&gt;: 任务完成（output 还没被读取）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;closed&lt;&#x2F;code&gt;: 任务关闭（任务被取消或者 output 已被读取）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;创建异步任务&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;创建异步任务 &lt;code&gt;fn spawn&amp;lt;F, S&amp;gt;(future: F, schedule: S) -&amp;gt; (Runnable, Task&amp;lt;F::Output&amp;gt;)&lt;&#x2F;code&gt; 需要传入 future 和 custom_schedule 方法，任务初始状态为 &lt;code&gt;scheduled&lt;&#x2F;code&gt;，返回 Runnable 和 Task。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Runnable&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;schedule&lt;&#x2F;code&gt; 方法：用于让 Executor 调度该任务，此方法仅调用 &lt;code&gt;custom_schedule&lt;&#x2F;code&gt; 方法，无其他行为&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;run&lt;&#x2F;code&gt; 方法：实际调用 &lt;code&gt;RawTask::run&lt;&#x2F;code&gt; 方法，用于让 Executor 对任务执行 poll 操作，如果任务执行完毕，则将状态改为 &lt;code&gt;completed&lt;&#x2F;code&gt;。如果任务是 &lt;code&gt;closed&lt;&#x2F;code&gt; 状态，会执行资源清理动作&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Task&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;poll_task&lt;&#x2F;code&gt; 方法：如果任务未完成，则注册 waker 并返回 &lt;code&gt;Poll::Pending&lt;&#x2F;code&gt;；如果任务完成了，则读取 output 并将任务置为 &lt;code&gt;closed&lt;&#x2F;code&gt; 状态&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;cancel&lt;&#x2F;code&gt; 方法：通过将任务置为 &lt;code&gt;closed&lt;&#x2F;code&gt; 状态，会重新发起一次调度，在执行任务过程中进行后续资源清理动作&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;detach&lt;&#x2F;code&gt; 方法：通过 &lt;code&gt;mem::forget&lt;&#x2F;code&gt; 来不 drop Task，将任务置于后台运行，运行结束后直接将任务置为 &lt;code&gt;closed&lt;&#x2F;code&gt; 状态&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Waker&lt;&#x2F;strong&gt;: 异步任务内部管理的用于传递给 Reactor 的 waker，当 IO 源 ready 时唤醒异步任务并触发一次调度，一个异步任务可以有多个 IO 源，所以也会有多个 waker&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;clone_waker&lt;&#x2F;code&gt;: 调用 &lt;code&gt;RawWaker::clone_waker&lt;&#x2F;code&gt; 克隆一个新的 waker&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;wake&lt;&#x2F;code&gt;: 通过将任务设置为 &lt;code&gt;scheduled&lt;&#x2F;code&gt; 状态并触发一次调度，清理 waker 关联资源&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;wake_by_ref&lt;&#x2F;code&gt;: 通过将任务设置为 &lt;code&gt;scheduled&lt;&#x2F;code&gt; 状态并触发一次调度&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;drop_waker&lt;&#x2F;code&gt;: 减少任务引用计数&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Awaiter&lt;&#x2F;strong&gt;：用户 await Task （如通过 block_on）时传入的 waker，当异步任务完成时唤醒用户再次 poll 获取 future 结果，一个异步任务对应至多一个 Awaiter（当任务后台运行时则没有）&lt;&#x2F;p&gt;
&lt;h2 id=&quot;async-executor&quot;&gt;async-executor&lt;&#x2F;h2&gt;
&lt;p&gt;async-executor 提供了两个简单的 executor 用于执行用户异步任务。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Executor：实现了 Send + Sync，支持多线程，spawn 方法限制 future 需要实现 Send&lt;&#x2F;li&gt;
&lt;li&gt;LocalExecutor：对 Executor 的包装，未实现 Send + Sync，限定单线程，spawn 方法不需要 future 实现 Send&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;核心数据结构为&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;State {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 全局队列
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;queue&lt;&#x2F;span&gt;&lt;span&gt;: ConcurrentQueue&amp;lt;Runnable&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 本地队列
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;local_queues&lt;&#x2F;span&gt;&lt;span&gt;: RwLock&amp;lt;Vec&amp;lt;Arc&amp;lt;ConcurrentQueue&amp;lt;Runnable&amp;gt;&amp;gt;&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 是否已通知 sleeper（不重复通知）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;notified&lt;&#x2F;span&gt;&lt;span&gt;: AtomicBool,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 等待全局队列新增任务（全局队列为空）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;sleepers&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Sleepers&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 当前活跃任务（通过持有 Waker 保持任务引用计数不归零）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;active&lt;&#x2F;span&gt;&lt;span&gt;: Mutex&amp;lt;Slab&amp;lt;Waker&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;调度任务（custom_schedule）：通过将任务加入到全局队列中，并通知 sleeper。&lt;&#x2F;li&gt;
&lt;li&gt;执行任务：从队列获取一个任务，调用 &lt;code&gt;Runnable::run&lt;&#x2F;code&gt; 方法对 future 执行一次 poll。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;有两种驱动 executor 的方法：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;tick：从全局队列选取一个任务来执行 poll，当全局队列无任务时，注册一个 sleeper 等待&lt;&#x2F;li&gt;
&lt;li&gt;run：传入一个 future，运行该 future 直至完成，在运行该 future 同时会运行所属本地队列的其他任务，如果本地队列为空会从全局队列窃取任务，如果全局队列为空会从其他本地队列窃取任务，如果都没有则注册一个 sleeper 等待&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-xian-yi-ge-duo-xian-cheng-yi-bu-yun-xing-shi&quot;&gt;实现一个多线程异步运行时&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; ex &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Executor::new();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    thread::scope(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;scope&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for _ in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;5 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            scope.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(ex.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(core::future::pending::&amp;lt;()&amp;gt;())));
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;block_on&lt;&#x2F;span&gt;&lt;span&gt;(async {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; listener &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;TcpListener::bind(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;127.0.0.1:8080&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(stream, addr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; listener.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;accept&lt;&#x2F;span&gt;&lt;span&gt;().await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; task &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; ex.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;handle_new_connection&lt;&#x2F;span&gt;&lt;span&gt;(stream, addr));
&lt;&#x2F;span&gt;&lt;span&gt;                task.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;detach&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        })
&lt;&#x2F;span&gt;&lt;span&gt;    })
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;handle_new_connection&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;_stream&lt;&#x2F;span&gt;&lt;span&gt;: TcpStream, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;addr&lt;&#x2F;span&gt;&lt;span&gt;: SocketAddr) {
&lt;&#x2F;span&gt;&lt;span&gt;    Timer::after(Duration::from_secs(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;)).await;
&lt;&#x2F;span&gt;&lt;span&gt;    println!(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{:?}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;] Handle connection from: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        thread::current().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;        addr
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 类似于 tokio 以下代码
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tokio&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; listener &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;TcpListener::bind(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;127.0.0.1:8080&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;).await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;loop &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let &lt;&#x2F;span&gt;&lt;span&gt;(stream, addr) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; listener.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;accept&lt;&#x2F;span&gt;&lt;span&gt;().await.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unwrap&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        tokio::spawn(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;handle_new_connection&lt;&#x2F;span&gt;&lt;span&gt;(stream, addr));
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于 Executor 非 static 生命周期，因此采用 Scoped threads 实现多线程，主线程负责监听端口获取新连接，并创建一个后台任务处理，子线程负责从本地队列（会从全局队列或其他本地队列窃取任务）读取任务进行执行。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>200 行 Rust 代码实现绿色线程 &#x2F; 有栈协程</title>
		<published>2024-10-29T00:00:00+00:00</published>
		<updated>2024-10-29T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/green-threads-in-200-lines-of-rust/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/green-threads-in-200-lines-of-rust/</id>
		<content type="html">&lt;p&gt;最近在清华大学 rCore 内核教程中看到这段 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;rcore-os&#x2F;rCore-Tutorial-v3&#x2F;blob&#x2F;main&#x2F;user&#x2F;src&#x2F;bin&#x2F;stackful_coroutine.rs&quot;&gt;200 行的示例代码&lt;&#x2F;a&gt;，觉得很有趣，但为了不跟 rCore 内核绑定，我将其移植到 Linux for RISC-V64 上，并且重构了许多代码，修复了一些问题，增强了其可读性，具体见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;systemxlabs&#x2F;green-threads-in-200-lines-of-rust&quot;&gt;https:&#x2F;&#x2F;github.com&#x2F;systemxlabs&#x2F;green-threads-in-200-lines-of-rust&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qian-zhi-zhi-shi-risc-v-jia-gou-he-han-shu-diao-yong-gui-yue&quot;&gt;前置知识：RISC-V 架构和函数调用规约&lt;&#x2F;h2&gt;
&lt;p&gt;RISC-V 是一个模块化的精简指令集架构，这里我们以 RV64I 模块（64 位基本整数指令集）为例&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;包含基本的整数运算指令（算术&#x2F;逻辑&#x2F;移位）、分支和跳转指令、内存交互指令&lt;&#x2F;li&gt;
&lt;li&gt;提供 32 个整数寄存器（x0-x31），其中 x0 硬连线为 0（恒为 0），这些寄存器有一些别名，如 x1 用于存放函数返回地址，也称 ra 寄存器，x2 用于存放栈指针，也称 sp 寄存器&lt;&#x2F;li&gt;
&lt;li&gt;指令长度为 32 位，寄存器位宽是 64&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;寄存器组&lt;&#x2F;th&gt;&lt;th&gt;保存者&lt;&#x2F;th&gt;&lt;th&gt;功能&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;a0~a7（x10~x17）&lt;&#x2F;td&gt;&lt;td&gt;调用者保存&lt;&#x2F;td&gt;&lt;td&gt;用来传递输入参数，其中的 a0 和 a1 还用来保存返回值&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;t0~t6 (x5~x7, x28~x31)&lt;&#x2F;td&gt;&lt;td&gt;调用者保存&lt;&#x2F;td&gt;&lt;td&gt;作为临时寄存器使用，在被调函数中可以随意使用无需保存&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;s0~s11 (x8~x9, x18~x27)&lt;&#x2F;td&gt;&lt;td&gt;被调用者保存&lt;&#x2F;td&gt;&lt;td&gt;作为临时寄存器使用，被调函数保存后才能在被调函数中使用，其中 fp (s0) 也可作为栈帧指针寄存器，表示当前栈帧的起始位置&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ra (x1)&lt;&#x2F;td&gt;&lt;td&gt;被调用者保存&lt;&#x2F;td&gt;&lt;td&gt;存放函数返回地址&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;sp (x2)&lt;&#x2F;td&gt;&lt;td&gt;被调用者保存&lt;&#x2F;td&gt;&lt;td&gt;栈指针寄存器，指向栈顶位置&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;zero (x0)&lt;&#x2F;td&gt;&lt;td&gt;N&#x2F;A&lt;&#x2F;td&gt;&lt;td&gt;恒为零&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;何为调用者保存寄存器和被调用者保存寄存器？&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;由于每个 CPU 只有一套寄存器，函数调用前后会导致寄存器的值被覆盖，因此需要将寄存器的值提前保存到栈上，后续从栈上恢复这些寄存器的值，这个过程由函数调用者和被调用者合作完成&lt;&#x2F;li&gt;
&lt;li&gt;被调用者保存 (Callee-Saved) 寄存器 ：被调用的函数可能会覆盖这些寄存器，需要被调用的函数来保存的寄存器，即由被调用的函数来保证在调用前后，这些寄存器保持不变&lt;&#x2F;li&gt;
&lt;li&gt;调用者保存 (Caller-Saved) 寄存器 ：被调用的函数可能会覆盖这些寄存器，需要发起调用的函数来保存的寄存器，即由发起调用的函数来保证在调用前后，这些寄存器保持不变&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;函数调用是通过压栈和出栈的方式，每个函数执行都有其对应的栈帧
&lt;img src=&quot;call-stack.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;一个函数可能的栈帧内容
&lt;img src=&quot;stack-frame.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
它的开头和结尾分别在 sp 和 fp 寄存器所指向的地址。按照地址从高到低分别有以下内容，它们都是通过 sp 加上一个偏移量来访问的：&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ra 寄存器保存子函数返回之后需要跳转的地址&lt;&#x2F;li&gt;
&lt;li&gt;父亲栈帧的结束地址 fp&lt;&#x2F;li&gt;
&lt;li&gt;其他被调用者保存寄存器 s1 ~ s11 &lt;&#x2F;li&gt;
&lt;li&gt;函数所使用到的局部变量&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;函数 A 调用函数 B 具体完整过程（抛开编译器优化）：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;函数 A 保存“调用者保存寄存器”到其栈帧内&lt;&#x2F;li&gt;
&lt;li&gt;函数 A 设置输入参数到 a0-a7 寄存器&lt;&#x2F;li&gt;
&lt;li&gt;函数 A 跳转到函数 B 入口并设置 ra 寄存器为函数 A 跳转指令的下一条指令地址（pc + 4），这个过程是一条指令完成&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 向下移动 sp 栈指针来分配其栈帧空间，例如 &lt;code&gt;addi sp, sp, -64&lt;&#x2F;code&gt; 分配 64 字节栈帧&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 保存 ra 寄存器到其栈帧内，例如 &lt;code&gt;sd  ra, 56(sp)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 保存“被调用者保存寄存器”到其栈帧内&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 更新 fp 寄存器为其栈帧顶端地址，例如 &lt;code&gt;addi fp, sp, 64&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 从 a0-a7 寄存器读取输入参数并执行（可能继续调用其他函数）&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 将返回值保存到 a0-a1 寄存器&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 从其栈帧内恢复 ra 寄存器，例如 &lt;code&gt;ld  ra, 56(sp)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 从其栈帧内恢复“被调用者保存寄存器”&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 向上移动 sp 栈指针来回收其栈帧空间，例如 &lt;code&gt;addi sp, sp, 64&lt;&#x2F;code&gt; 回收 64 字节栈帧&lt;&#x2F;li&gt;
&lt;li&gt;函数 B 跳转到 ra 寄存器指向的返回地址，例如 &lt;code&gt;jalr x0, 0(ra)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;函数 A 从其栈帧内恢复“调用者保存寄存器”&lt;&#x2F;li&gt;
&lt;li&gt;函数 A 继续向下执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;更详细介绍可见&lt;a href=&quot;https:&#x2F;&#x2F;rcore-os.cn&#x2F;rCore-Tutorial-Book-v3&#x2F;chapter1&#x2F;5support-func-call.html&quot;&gt;此文章&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;注：以下线程均指绿色线程。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ding-yi-yi-ge-xian-cheng&quot;&gt;定义一个线程&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;Thread {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stack&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ctx&lt;&#x2F;span&gt;&lt;span&gt;: ThreadContext,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;state&lt;&#x2F;span&gt;&lt;span&gt;: State,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;enum &lt;&#x2F;span&gt;&lt;span&gt;State {
&lt;&#x2F;span&gt;&lt;span&gt;    Available,
&lt;&#x2F;span&gt;&lt;span&gt;    Running,
&lt;&#x2F;span&gt;&lt;span&gt;    Ready,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;repr&lt;&#x2F;span&gt;&lt;span&gt;(C)]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ThreadContext {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;ra&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;sp&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s0&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s1&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s2&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s3&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s4&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s5&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s6&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s7&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s8&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s9&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s10&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;s11&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;entry&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一个线程包含：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;线程 id&lt;&#x2F;li&gt;
&lt;li&gt;执行状态：Availabe 表示空闲，可分配新任务执行；Running 表示正在执行任务；Ready 表示已分配任务，可以被调度执行，任务可能未开始也可能被中途挂起了&lt;&#x2F;li&gt;
&lt;li&gt;任务上下文：被调用者保存寄存器，用于恢复挂起的任务继续执行；entry 是任务的入口地址，只在首次被调度时使用&lt;&#x2F;li&gt;
&lt;li&gt;栈：分配在进程对应的堆区（固定大小、不会扩容）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;ding-yi-xian-cheng-yun-xing-shi&quot;&gt;定义线程运行时&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;static mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RUNTIME&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Runtime {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;threads&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Thread&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;current&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Runtime {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;() -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; base_thread_id &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; base_thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Thread::new_with_state(base_thread_id, State::Running);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; threads &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;vec![base_thread];
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; available_threads &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;MAX_THREADS &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;i&lt;&#x2F;span&gt;&lt;span&gt;| Thread::new(i)).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;collect&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        threads.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;append&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; available_threads);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        Runtime {
&lt;&#x2F;span&gt;&lt;span&gt;            threads,
&lt;&#x2F;span&gt;&lt;span&gt;            current: base_thread_id,
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; r_ptr: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt; Runtime &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RUNTIME &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; r_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as usize&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;运行时在创建时会预创建若干线程，current 代表正在执行的线程&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;一个 base 线程，用于 Runtime 本身的代码执行，此时处于 Runtime 执行流，因此状态为 Running&lt;&#x2F;li&gt;
&lt;li&gt;若干 user 线程，用于用户任务的代码执行，此时没有绑定任务，因此状态均为 Available&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;使用全局变量存储 Runtime 地址，便于后续全局访问 Runtime。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;chuang-jian-yong-hu-ren-wu&quot;&gt;创建用户任务&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Runtime {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn&lt;&#x2F;span&gt;&lt;span&gt;()) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; available &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self
&lt;&#x2F;span&gt;&lt;span&gt;            .threads
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;iter_mut&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;find&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;| t.state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span&gt;State::Available)
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;expect&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;no available green thread.&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;RUNTIME: spawning task on green thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, available.id);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; available.stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; available.stack.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;as_mut_ptr&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;offset&lt;&#x2F;span&gt;&lt;span&gt;(size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as isize&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(s_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as usize &amp;amp; !&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;7&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as *mut u8&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;            available.ctx.ra &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; task_return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; task return address
&lt;&#x2F;span&gt;&lt;span&gt;            available.ctx.sp &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; s_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; stack pointer
&lt;&#x2F;span&gt;&lt;span&gt;            available.ctx.entry &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; f &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as u64&lt;&#x2F;span&gt;&lt;span&gt;; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; task entry address
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        available.state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;State::Ready;
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_return&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current].state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;State::Available;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_schedule&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;task_return&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rt_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RUNTIME &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Runtime;
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;rt_ptr).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_return&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;用户任务是一个无参数的函数，创建任务就是将函数跑在线程上。&lt;&#x2F;p&gt;
&lt;p&gt;创建过程：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;首先找到一个空闲的线程，然后初始化其栈顶指针为其所属栈空间 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;&#x2F;code&gt; 的最高地址，并确保 8 字节对齐（RISC-V64 要求 ld&#x2F;sd 访存指令的数据地址是 8 字节对齐）&lt;&#x2F;li&gt;
&lt;li&gt;设定任务入口地址为函数 &lt;code&gt;f&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;设定任务返回地址为 &lt;code&gt;task_return&lt;&#x2F;code&gt; 函数，当任务执行完毕时，会跳转到 &lt;code&gt;task_return&lt;&#x2F;code&gt; 地址执行，然后调用 &lt;code&gt;Runtime::t_return()&lt;&#x2F;code&gt; 来标记当前线程空闲，并调度&#x2F;切换到下一个 ready 的线程继续执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;diao-du-xian-cheng&quot;&gt;调度线程&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Runtime {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_yield&lt;&#x2F;span&gt;&lt;span&gt;() {}
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;All tasks finished!&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_yield&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current].state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;State::Ready;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_schedule&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_schedule&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; thread_count &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;len&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; pos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span&gt; thread_count;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;while &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[pos].state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;!= &lt;&#x2F;span&gt;&lt;span&gt;State::Ready {
&lt;&#x2F;span&gt;&lt;span&gt;            pos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;(pos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;+ &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;%&lt;&#x2F;span&gt;&lt;span&gt; thread_count;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; pos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current {
&lt;&#x2F;span&gt;&lt;span&gt;                &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;return &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;RUNTIME: schedule next thread &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt; to be run&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, pos);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[pos].state &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;State::Running;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_pos &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.current &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; pos;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;switch&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[old_pos].ctx, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.threads[pos].ctx);
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;yield&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; rt_ptr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;RUNTIME &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as *mut&lt;&#x2F;span&gt;&lt;span&gt; Runtime;
&lt;&#x2F;span&gt;&lt;span&gt;        (&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt;rt_ptr).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;t_yield&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    };
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;t_schedule&lt;&#x2F;code&gt; 方法：用于寻找下一个 ready 的线程并从当前线程切换过去&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;t_yield&lt;&#x2F;code&gt; 方法：用于挂起当前线程，并调用 &lt;code&gt;t_schedule&lt;&#x2F;code&gt; 方法切到下一个 ready 的线程&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;run&lt;&#x2F;code&gt; 方法：启动 Runtime，不断循环调用 &lt;code&gt;t_yield&lt;&#x2F;code&gt; 来挂起自身（base 线程），然后切换到下一个 ready 的 user 线程，直至用户任务均执行完毕&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;r#yield&lt;&#x2F;code&gt; 函数：用户任务代码使用此函数挂起所在线程&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;qie-huan-xian-cheng&quot;&gt;切换线程&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;naked&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;no_mangle&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;unsafe extern &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;C&amp;quot; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;switch&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;old&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*mut&lt;&#x2F;span&gt;&lt;span&gt; ThreadContext, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;new&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*const&lt;&#x2F;span&gt;&lt;span&gt; ThreadContext) {
&lt;&#x2F;span&gt;&lt;span&gt;    naked_asm!(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd ra, 0*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd sp, 1*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s0, 2*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s1, 3*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s2, 4*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s3, 5*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s4, 6*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s5, 7*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s6, 8*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s7, 9*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s8, 10*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s9, 11*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s10, 12*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd s11, 13*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        sd ra, 14*8(a0)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld ra, 0*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld sp, 1*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s0, 2*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s1, 3*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s2, 4*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s3, 5*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s4, 6*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s5, 7*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s6, 8*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s7, 9*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s8, 10*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s9, 11*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s10, 12*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld s11, 13*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        ld t0, 14*8(a1)
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;        jr t0
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;    &amp;quot;
&lt;&#x2F;span&gt;&lt;span&gt;    );
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;由于需要精确操作寄存器，使用内联汇编实现&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;函数的两个入参保存在 a0 和 a1 寄存器&lt;&#x2F;li&gt;
&lt;li&gt;使用裸函数：无需编译器在开头生成保存寄存器的汇编（Prologue）和在结尾生成恢复寄存器的汇编（Epilogue）（也可以使用 &lt;code&gt;global_asm!&lt;&#x2F;code&gt; 宏实现，参见仓库代码）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在第一次执行 switch 函数时，从 base 线程切换到 user 线程&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;保存 Runtime 执行流上下文到 base 线程对应的 ThreadContext 中（后续才能切换回 base 线程继续向下执行 Runtime 代码）&lt;&#x2F;li&gt;
&lt;li&gt;加载首个任务执行上下文，&lt;code&gt;ld t0, 14*8(a1)&lt;&#x2F;code&gt; 加载用户任务入口地址（ThreadContext 中 entry 值），所以可以跳转到任务开头向下执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在 switch 函数从某个 user 线程第一次切换出去时&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;保存当前 user 线程上下文到对应的 ThreadContext 中，此时 ThreadContext 中的任务入口地址 entry 会被实际的返回地址覆盖（这样后续切换回来不会导致又从头开始执行任务）&lt;&#x2F;li&gt;
&lt;li&gt;恢复下一个线程上下文并继续执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;yong-hu-dai-ma-ce-shi&quot;&gt;用户代码测试&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;const &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;MAX_THREADS&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;4&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;static &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;FINISHED_TASK_COUNT&lt;&#x2F;span&gt;&lt;span&gt;: AtomicUsize &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;AtomicUsize::new(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;main&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; runtime &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;Runtime::new();
&lt;&#x2F;span&gt;&lt;span&gt;    runtime.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    runtime.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_task&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    runtime.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_task&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    runtime.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;spawn&lt;&#x2F;span&gt;&lt;span&gt;(|| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_task&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;    runtime.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;run&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;FINISHED_TASK_COUNT&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;load&lt;&#x2F;span&gt;&lt;span&gt;(Ordering::SeqCst), &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;3&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_task&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;task_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;) {
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;TASK &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt; STARTING&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, task_id);
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; i &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;..&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;4 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; task_id {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;task: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt; counter: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, task_id, i);
&lt;&#x2F;span&gt;&lt;span&gt;        r&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;#&lt;&#x2F;span&gt;&lt;span style=&quot;background-color:#e06c75;color:#fafafa;&quot;&gt;yield&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;FINISHED_TASK_COUNT&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fetch_add&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;1&lt;&#x2F;span&gt;&lt;span&gt;, Ordering::SeqCst);
&lt;&#x2F;span&gt;&lt;span&gt;    println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;TASK &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt; FINISHED&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, task_id);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;在 Runtime 运行之前，有 1 个 Running 状态的 base 线程、3 个 Ready 状态的 user 线程和 1 个 Available 状态的 user 线程&lt;&#x2F;li&gt;
&lt;li&gt;base 线程会在 Running 和 Ready 状态之间不断切换&lt;&#x2F;li&gt;
&lt;li&gt;3 个 user 线程会在 Running 和 Ready 状态之间不断切换，当任务执行完毕后，变成 Available 状态&lt;&#x2F;li&gt;
&lt;li&gt;1 个 user 线程始终保持在 Available 状态&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;输出&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;RUNTIME: spawning task on green thread 1
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: spawning task on green thread 2
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: spawning task on green thread 3
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 1 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 1 STARTING
&lt;&#x2F;span&gt;&lt;span&gt;task: 1 counter: 0
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 2 STARTING
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 0
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 3 STARTING
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 0
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 1 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 1 counter: 1
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 1
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 1
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 1 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 1 counter: 2
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 2
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 2
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 1 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 1 counter: 3
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 3
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 3
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 1 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 1 FINISHED
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 4
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 4
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 5
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 5
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 6
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 6
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 2 counter: 7
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 7
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 2 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 2 FINISHED
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 8
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 9
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 10
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;task: 3 counter: 11
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 3 to be run
&lt;&#x2F;span&gt;&lt;span&gt;TASK 3 FINISHED
&lt;&#x2F;span&gt;&lt;span&gt;RUNTIME: schedule next thread 0 to be run
&lt;&#x2F;span&gt;&lt;span&gt;All tasks finished!
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DataFusion 查询引擎两阶段并行哈希分组聚合</title>
		<published>2024-08-23T00:00:00+00:00</published>
		<updated>2024-08-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-grouped-aggregations/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-grouped-aggregations/</id>
		<content type="html">&lt;p&gt;分组聚合功能是任何分析引擎的核心功能，可在海量数据上创建出可以理解的摘要。DataFusion 分析引擎采用了先进的两阶段并行哈希分组聚合技术（two-phase parallel hash partitioned grouping），高度并行且向量化执行。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;duo-chong-ju-he-fang-an&quot;&gt;多种聚合方案&lt;&#x2F;h2&gt;
&lt;p&gt;DataFusion 支持多种聚合方案，在不同情况下会选择最优方案。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-jie-duan-wu-ha-xi-fen-qu-single&quot;&gt;一阶段无哈希分区（Single）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-single.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Aggregate 算子接收所有输入数据串行执行&lt;&#x2F;li&gt;
&lt;li&gt;一个 Aggregate 算子完成所有分组聚合工作&lt;&#x2F;li&gt;
&lt;li&gt;场景：通常输入只有一个分区&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;yi-jie-duan-you-ha-xi-fen-qu-singlepartitioned&quot;&gt;一阶段有哈希分区（SinglePartitioned）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-single-partitioned.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;输入必须按照 group keys 进行了重新分区（repartition）&lt;&#x2F;li&gt;
&lt;li&gt;一个 Aggregate 算子完成所有分组聚合工作&lt;&#x2F;li&gt;
&lt;li&gt;Aggregate 算子接收多个分区数据并行执行&lt;&#x2F;li&gt;
&lt;li&gt;场景：通常输入有多个分区，且都已经按 group keys 重新分区了&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;liang-jie-duan-wu-ha-xi-fen-qu-partial-final&quot;&gt;两阶段无哈希分区（Partial-Final）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-partial-final.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段 Aggregate 算子接收多个分区数据并行执行，计算中间聚合结果&lt;&#x2F;li&gt;
&lt;li&gt;第二阶段 Aggregate 算子接收所有分区中间聚合结果数据串行执行，生成最终聚合结果&lt;&#x2F;li&gt;
&lt;li&gt;场景：通常输入有多个分区，查询没有 group by 语句 或者 用户设置并行度为 1（输出一个分区）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;liang-jie-duan-you-ha-xi-fen-qu-partial-finalpartioned&quot;&gt;两阶段有哈希分区（Partial-FinalPartioned）&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-partial-final-partitioned.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段 Aggregate 算子接收多个分区数据并行执行，计算中间聚合结果&lt;&#x2F;li&gt;
&lt;li&gt;第二阶段 Aggregate 算子接收多个分区中间聚合结果数据并行执行，并行生成最终聚合结果&lt;&#x2F;li&gt;
&lt;li&gt;第二阶段输入必须按照 group key 进行了重新分区&lt;&#x2F;li&gt;
&lt;li&gt;场景：通常输入有多个分区（没有按 group keys 重新分区），查询有 group by 语句，且并行度大于 1&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;liang-jie-duan-bing-xing-ha-xi-fen-zu-ju-he-partial-finalpartioned&quot;&gt;两阶段并行哈希分组聚合（Partial-FinalPartioned）&lt;&#x2F;h2&gt;
&lt;p&gt;以 &lt;code&gt;select a, b, avg(c) from t group by a, b&lt;&#x2F;code&gt; 为例。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;di-yi-jie-duan-partial&quot;&gt;第一阶段（Partial）&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;不断从输入读取一批一批数据 &lt;code&gt;(a, b, c)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;执行表达式求值和中间聚合计算，在内存中维护 group 值到中间聚合结果 &lt;code&gt;(a, b) -&amp;gt; (count(c), sum(c))&lt;&#x2F;code&gt; 的哈希表&lt;&#x2F;li&gt;
&lt;li&gt;如果输入已按照 group keys 排序，则利用排序特性，提前输出部分已聚合完毕 group 的中间聚合结果到第二阶段（可以清空这部分内存）&lt;&#x2F;li&gt;
&lt;li&gt;如果发现内存不足，则提前输出（early emit）内存中所有的已计算的中间聚合结果到第二阶段，清空内存中的哈希表&lt;&#x2F;li&gt;
&lt;li&gt;如果发现是高基数聚合，则跳过聚合计算（不维护哈希表），将每行输入直接转换为中间聚合结果表达形式，输出到第二阶段&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;di-er-jie-duan-finalpartitioned&quot;&gt;第二阶段（FinalPartitioned）&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;不断从输入读取一批一批中间聚合数据 &lt;code&gt;(a, b, count(c), sum(c))&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;将相同 group 的中间聚合结果合并，在内存中维护 group 值到中间聚合结果 &lt;code&gt;(a, b) -&amp;gt; (count(c), sum(c))&lt;&#x2F;code&gt; 的哈希表&lt;&#x2F;li&gt;
&lt;li&gt;如果输入已按照 group keys 排序，则利用排序特性，提前输出部分已聚合完毕的 group，会基于中间聚合结果计算最终聚合结果 &lt;code&gt;avg(c)&lt;&#x2F;code&gt;，然后输出到下一算子（可以清空这部分内存）&lt;&#x2F;li&gt;
&lt;li&gt;如果内存不足，则将内存中的哈希表溢出到磁盘（spill），溢出前会先按照 group keys 排好序，以 Arrow IPC 格式写入磁盘文件，然后清空内存哈希表，最后会将多个溢出文件以流的形式执行合并操作（stream merge），计算最终聚合结果 &lt;code&gt;avg(c)&lt;&#x2F;code&gt; 并输出到下一算子&lt;&#x2F;li&gt;
&lt;li&gt;如果内存充足，则最后将整个内存中的哈希表，计算最终聚合结果 &lt;code&gt;avg(c)&lt;&#x2F;code&gt; 并输出到下一算子&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;nei-cun-zhong-de-ha-xi-biao&quot;&gt;内存中的哈希表&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-hashtable.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;以上在逻辑上形成一个哈希表，group 索引、group 值和 &lt;code&gt;Accumulator&lt;&#x2F;code&gt; 一一对应，但物理上并非直接使用哈希表存储 group 到聚合状态的映射，实际上哈希表维护的是 group 值到 group 索引的映射，哈希表负责分配 group 索引，而另外有一个 &lt;code&gt;Accumulator组&lt;&#x2F;code&gt; 的数据结构通过类似 Vec 的结构存储每个 group 的聚合状态，每个 group 索引会对应其中一个 Accumulator。&lt;&#x2F;p&gt;
&lt;p&gt;在接收一批数据时，先由哈希表来计算这批数据每行对应的 group 索引（可能是已存在的，也可能会分配一个新的），然后将这批数据和每行对应的 group 索引发送给 &lt;code&gt;Accumulator组&lt;&#x2F;code&gt; 来进行聚合状态更新。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Accumulator组&lt;&#x2F;code&gt; 在更新前会利用 Arrow 计算内核对数据进行一个高效地重排，以便在更新聚合状态时，可以被编译器很好地向量化（SIMD加速）。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-reorder-accumulator-input.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;利用类似 &lt;code&gt;Vec&lt;&#x2F;code&gt; 连续内存存储，尽可能减少内存分配，尽可能类型特化，可以最大化提高聚合计算效率。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;group-zai-fen-qu-shang-de-fen-bu&quot;&gt;group 在分区上的分布&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-group-distribution.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;在第一阶段，每个分区上都可能存在任意的 group，在进入第二阶段前，会按照 group keys 进行重新分区，因此在第二阶段，每个分区上的 group 不会存在重叠。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;li-yong-shu-ru-de-pai-xu-te-xing&quot;&gt;利用输入的排序特性&lt;&#x2F;h3&gt;
&lt;p&gt;DataFusion 会利用聚合算子的输入在 group keys 上的（部分&#x2F;完全）排序特性，来加速聚合计算。&lt;&#x2F;p&gt;
&lt;p&gt;假如聚合算子输入按照 group keys &lt;code&gt;a&lt;&#x2F;code&gt; 和 &lt;code&gt;b&lt;&#x2F;code&gt; 完全排序，&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-grouped-aggregations&#x2F;.&#x2F;datafusion-aggregation-full-group-ordering.drawio.png&quot; alt=&quot;&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;当出现新的 group 值时，说明前面的 group 已经聚合完毕，不会再有新的行出现，此时我们可以将前面 group 聚合计算结果提前发送到下一阶段算子。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gao-ji-shu-ju-he-tiao-guo-di-yi-jie-duan&quot;&gt;高基数聚合跳过第一阶段&lt;&#x2F;h3&gt;
&lt;p&gt;当出现高基数聚合（group 比较分散，默认阈值是行数大于 100000 并且 group 数量与行数比值大于 0.8）时，这时第一阶段在内存中需要维护巨大的哈希表，不仅浪费内存，而且第一阶段并不能显著减少数据量，此时会跳过第一阶段内的聚合计算，每行数据 &lt;code&gt;(a, b, c)&lt;&#x2F;code&gt; 直接被转换为中间聚合结果形式 &lt;code&gt;(a, b, count(c), sum(c))&lt;&#x2F;code&gt;，然后输出到第二阶段。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;topk-ju-he&quot;&gt;TopK 聚合&lt;&#x2F;h3&gt;
&lt;p&gt;当查询（&lt;code&gt;... order by xxx limit xxx&lt;&#x2F;code&gt;）满足特定条件时，&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;blob&#x2F;a4445283dbff1b74a6b4d9ecfa1016857dc6207e&#x2F;datafusion&#x2F;core&#x2F;src&#x2F;physical_optimizer&#x2F;topk_aggregation.rs&quot;&gt;优化规则&lt;&#x2F;a&gt;会将 limit 下推到 Aggregate 算子，在执行时会直接走 TopK 聚合计算，采用一种 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;blob&#x2F;a4445283dbff1b74a6b4d9ecfa1016857dc6207e&#x2F;datafusion&#x2F;physical-plan&#x2F;src&#x2F;aggregates&#x2F;topk&#x2F;priority_map.rs&quot;&gt;Map 和优先队列的组合结构&lt;&#x2F;a&gt;，避免在内存中维护巨大的哈希表，减少内存占用以及计算量。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;qi-ta-yi-xie-wen-ti&quot;&gt;其他一些问题&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;strong&gt;第一阶段判断是否跳过聚合计算时，为什么需要输入无任何在 group keys 上的排序特性？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;因为如果输入具有排序特性，那么可以利用排序特性来提前输出部分已聚合完毕的 group，这样不会因为高基数聚合导致需要在内存中维护巨大的哈希表。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;为什么 Spill（溢出到磁盘）仅发生在第二阶段（FinalPartitioned），而不会在第一阶段（Partial）发生？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Spill 是一个耗时的操作，涉及到磁盘 IO 和排序，而且对于高基数聚合（group 非常分散），很可能在第二阶段仍需要 Spill。所以通常的做法是在第一阶段内存不足时将内存中数据提前输出到第二阶段（early emit），在第二阶段内存不足时采用 Spill 溢出到磁盘。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;为什么 Spill（溢出到磁盘）之前需要对数据按照 group keys 进行排序？&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;如果发生 Spill，说明数据量过大内存不足，无法在内存中对数据进行分组，唯一的方式就是进行流式地 &lt;code&gt;读取-聚合-输出&lt;&#x2F;code&gt;。所以我们提前对 Spill 到磁盘的数据进行排序，在流式读取所有磁盘文件时执行合并（stream merge），利用输入的完全排序特性，可以流式地输出一组组聚合结果。&lt;&#x2F;p&gt;
&lt;p&gt;参考资料&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arrow.apache.org&#x2F;blog&#x2F;2023&#x2F;08&#x2F;05&#x2F;datafusion_fast_grouping&#x2F;&quot;&gt;Aggregating Millions of Groups Fast in Apache Arrow DataFusion&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Rust 无畏并发的基础 Send 和 Sync</title>
		<published>2024-07-06T00:00:00+00:00</published>
		<updated>2024-07-06T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/rust-send-sync/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/rust-send-sync/</id>
		<content type="html">&lt;h2 id=&quot;xian-cheng-bu-an-quan-de-yuan-yin&quot;&gt;线程不安全的原因&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;数据竞争，是指多个线程在同一时刻对同一个数据进行读写或者写写。&lt;&#x2F;li&gt;
&lt;li&gt;数据的某些操作跟特定线程绑定在一起。比如 &lt;a href=&quot;https:&#x2F;&#x2F;pubs.opengroup.org&#x2F;onlinepubs&#x2F;009695399&#x2F;functions&#x2F;pthread_mutex_lock.html&quot;&gt;pthread_mutex_lock&lt;&#x2F;a&gt; 的 unlock 操作必须在其 lock 线程执行，否则会 &lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Undefined_behavior&quot;&gt;undefined behavior&lt;&#x2F;a&gt;，比如窗口管理 winit 中的 EventLoop 必须在主线程创建和执行。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;send-he-sync-ding-yi&quot;&gt;Send 和 Sync 定义&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Send.html&quot;&gt;Send&lt;&#x2F;a&gt;：Types that can be transferred across thread boundaries&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;类型可以在线程间安全地被复制或着移动。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;几乎所有 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;index.html#primitives&quot;&gt;primitives 类型&lt;&#x2F;a&gt;都是 Send，比如 bool、i32、array等，而裸指针 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html&quot;&gt;pointer&lt;&#x2F;a&gt; 类型并不是&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: Sync + ?Sized&amp;gt; Send for &amp;amp;T {}&lt;&#x2F;code&gt; 表示如果 T 是 Sync，其不可变引用 &amp;amp;T 可以复制到其他线程被安全地使用&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Sync.html&quot;&gt;Sync&lt;&#x2F;a&gt;：Types for which it is safe to share references between threads&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;类型可以在线程间安全地共享引用。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;这里共享的引用指 &amp;amp;T，因为 &amp;amp;mut T 天然地被 Rust 借用规则限制，不可能两个线程同时拥有 &amp;amp;mut T&lt;&#x2F;li&gt;
&lt;li&gt;由于 Rust 的&lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;reference&#x2F;interior-mutability.html&quot;&gt;内部可变性模式&lt;&#x2F;a&gt;，&amp;amp;T 并不能保证只读数据，因此 Sync 解决的问题就是 &amp;amp;T 跨线程的安全性&lt;&#x2F;li&gt;
&lt;li&gt;不具有内部可变性的类型，其引用 &amp;amp;T 只读数据，因此 T 可以跨线程共享引用，满足 Sync
&lt;ul&gt;
&lt;li&gt;几乎所有 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;index.html#primitives&quot;&gt;primitives 类型&lt;&#x2F;a&gt;都是 Sync，比如 bool、i32、array等，而裸指针 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;primitive.pointer.html&quot;&gt;pointer&lt;&#x2F;a&gt; 类型并不是&lt;&#x2F;li&gt;
&lt;li&gt;基于以上 primitives 的 struct、tuple 和 enum 也都会自动实现 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;内部可变性原语 UnsafeCell 不是 Sync
&lt;ul&gt;
&lt;li&gt;在其上没有通过同步机制构建的类型（比如 Rc 和 RefCell）也不是 Sync&lt;&#x2F;li&gt;
&lt;li&gt;在其上通过同步机制构建的类型（比如 AtomicBool、Arc、Mutex 等）则可以是 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Send 和 Sync 都是 auto marker trait，编译器会自动给每个符合的类型自动实现该 trait，也可以手动通过 &lt;code&gt;impl !Send for XXX&lt;&#x2F;code&gt; 来显示地标识某类型不是 Send。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tui-dao-jie-lun&quot;&gt;推导结论&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;T: Sync &amp;lt;=&amp;gt; &amp;amp;T: Send&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;如果 T 是 Sync，说明可以在线程间安全的共享引用，所以 &amp;amp;T 可以被安全的 Send。相反，如果 T 不是 Sync，那么其引用 &amp;amp;T 就不能被安全地 Send&lt;&#x2F;li&gt;
&lt;li&gt;如果 &amp;amp;T 是 Send，说明 T 的引用可以在线程间安全地发送，所以 T 是 Sync。相反，如果 &amp;amp;T 不能安全的 Send，那么 T 就不是 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;T: Sync &amp;lt;=&amp;gt; &amp;amp;T: Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;T 是 Sync，所以 &amp;amp;T 是 Send。&amp;amp;T 是 Sync 的前提是 &amp;amp;&amp;amp;T 为 Send，而 &amp;amp;&amp;amp;T 实际就是 &amp;amp;T（共享是可传递的），所以 &amp;amp;&amp;amp;T 也是 Send，那么 &amp;amp;T 则为 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;T: Sync &amp;lt;=&amp;gt; &amp;amp;mut T: Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;T 是 Sync，所以 &amp;amp;T 是 Send。&amp;amp;mut T 是 Sync 的前提是 &amp;amp;&amp;amp;mut T 为 Send，而 &amp;amp;&amp;amp;mut T 实际就是 &amp;amp;T，所以 &amp;amp;&amp;amp;mut T 也是 Send，那么 &amp;amp;mut T 则为 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;T: Send &amp;lt;=&amp;gt; &amp;amp;mut T: Send&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&amp;amp;mut T 某种程度可以看作拥有 T 的所有权（只不过它不能将 T 完全 drop，需要保证引用在其生命周期内有效），因为 &amp;amp;mut T 可以通过 &lt;code&gt;*ref = T&lt;&#x2F;code&gt; 来覆写其整个数据（原数据被 drop），也可以通过 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;mem&#x2F;fn.replace.html&quot;&gt;std::mem::replace&lt;&#x2F;a&gt; 将其指向的原数据 move 走&lt;&#x2F;li&gt;
&lt;li&gt;所以 &amp;amp;mut T 是 Send 的前提是 T 必须可以在线程间安全地 move，即 T 为 Send&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;以上结论的两边都是等价的，可以互相推导。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-ji-li-zi&quot;&gt;实际例子&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Send + Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;绝大多数 &lt;a href=&quot;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;index.html#primitives&quot;&gt;primitives 类型&lt;&#x2F;a&gt;：bool、i32、array&lt;&#x2F;li&gt;
&lt;li&gt;Atomic* 类型：AtomicBool、AtomicI32&lt;&#x2F;li&gt;
&lt;li&gt;基于 Send + Sync 类型构建的 struct、tuple、enum&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Send + !Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Cell 和 RefCell，其拥有内部可变性，但并没有使用同步机制&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;!Send + Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;MutexGuard，必须在加锁的线程上去释放锁（发生在 drop 时），因此不能 Send 到其他线程上被 drop。MutexGuard 可以通过 DerefMut 获取 &amp;amp;mut T，因此当 T 是 Sync 时，MutexGuard 才是 Sync（&lt;code&gt;impl&amp;lt;T: ?Sized + Sync&amp;gt; Sync for MutexGuard&amp;lt;&#x27;_, T&amp;gt;&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;!Send + !Sync&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Rc，其内部引用计数非原子更新，Rc 和 &amp;amp;Rc 均无法发送到其他线程，因为两者都可以通过 clone 改变内部引用计数器&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Arc&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Sync + Send, A: Allocator + Send&amp;gt; Send for Arc&amp;lt;T, A&amp;gt; {}&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;因为 Arc 是共享所有权，因此不确定 T 最终会在哪个线程上被 drop，因此 Arc 是 Send 的前提之一是 T 是 Send&lt;&#x2F;li&gt;
&lt;li&gt;Arc 可以通过 Deref 拿到 &amp;amp;T，因此在线程间发送 Arc 等价于发送 &amp;amp;T，而 &amp;amp;T 可以被安全发送的前提是 T 必须是 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Sync + Send, A: Allocator + Sync&amp;gt; Sync for Arc&amp;lt;T, A&amp;gt; {}&lt;&#x2F;code&gt;，在线程间发送 Arc 或其引用 &amp;amp;Arc 本质是一样的，因为两者都可以通过 clone 拿到一个新的 Arc&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Mutex&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Send for Mutex&amp;lt;T&amp;gt; {}&lt;&#x2F;code&gt;，如果 T 不是 Send，那么 Mutex 被发送到其他线程后获取锁 MutexGuard，进而通过 DerefMut 获取到 &amp;amp;mut T，而 &amp;amp;mut T 可以将其原值 drop 或者 move，存在问题。因此 T 必须 Send，Mutex 才会是 Send&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Sync for Mutex&amp;lt;T&amp;gt; {}&lt;&#x2F;code&gt;，如果 T 不是 Send，那么 Mutex 的引用被共享到其他线程后仍能获取锁 MutexGuard，进而通过 DerefMut 获取到 &amp;amp;mut T，而 &amp;amp;mut T 可以将其原值 drop 或者 move，存在问题。因此 T 必须 Send，Mutex 才会是 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;RwLock&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Send&amp;gt; Send for RwLock&amp;lt;T&amp;gt; {}&lt;&#x2F;code&gt;，如果 T 不是 Send，那么 RwLock 被发送到其他线程后获取写锁 RwLockWriteGuard，进而通过 DerefMut 获取到 &amp;amp;mut T，而 &amp;amp;mut T 可以将其原值 drop 或者 move，存在问题。因此 T 必须 Send，RwLock 才会是 Send&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;unsafe impl&amp;lt;T: ?Sized + Send + Sync&amp;gt; Sync for RwLock&amp;lt;T&amp;gt; {}&lt;&#x2F;code&gt;
&lt;ul&gt;
&lt;li&gt;如果 T 不是 Send，那么 RwLock 的引用被共享到其他线程后仍能获取写锁 RwLockWriteGuard，进而通过 DerefMut 获取到 &amp;amp;mut T，而 &amp;amp;mut T 可以将其原值 drop 或者 move，存在问题。因此 T 必须 Send，RwLock 才会是 Sync&lt;&#x2F;li&gt;
&lt;li&gt;如果 T 不是 Sync，那么 RwLock 的引用被共享到其他线程后可能多个线程同时获取到读锁 RwLockReadGuard，进而通过 Deref 获取到 &amp;amp;T，而 T 不是 Sync 的话，那么多线程同时使用 &amp;amp;T 存在问题。因此 T 必须 Sync，RwLock 才会是 Sync&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;RwLock 跟 Mutex 的区别就在于其读锁可以同时获取多个进行并发地读&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;参考：&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;https:&#x2F;&#x2F;users.rust-lang.org&#x2F;t&#x2F;example-of-a-type-that-is-not-send&#x2F;59835&#x2F;3&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;nomicon&#x2F;send-and-sync.html&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Send.html&lt;&#x2F;li&gt;
&lt;li&gt;https:&#x2F;&#x2F;doc.rust-lang.org&#x2F;std&#x2F;marker&#x2F;trait.Sync.html&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DataFusion 查询引擎 UDF 设计</title>
		<published>2024-06-03T00:00:00+00:00</published>
		<updated>2024-06-03T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-udf/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-udf/</id>
		<content type="html">&lt;p&gt;UDF 是指用户自定义标量函数（Scalar User Defined Functions），函数为输入的每一行生成一行输出。DataFusion 中使用 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;datafusion&#x2F;38.0.0&#x2F;datafusion&#x2F;logical_expr&#x2F;trait.ScalarUDFImpl.html&quot;&gt;ScalarUDFImpl&lt;&#x2F;a&gt; trait 对 UDF 进行抽象，用户 UDF 只需实现该 trait 并将其注册到 SessionContext 即可使用。DataFusion 内置标量函数和用户 UDF 均使用同一套 API &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;datafusion&#x2F;38.0.0&#x2F;datafusion&#x2F;logical_expr&#x2F;trait.ScalarUDFImpl.html&quot;&gt;ScalarUDFImpl&lt;&#x2F;a&gt; 实现。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 移除了部分兼容性代码（看起来会更简洁）
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ScalarUDFImpl: Debug + Send + Sync {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;as_any&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn Any;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;aliases&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[String] {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[]
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;display_name&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[Expr]) -&amp;gt; Result&amp;lt;String&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; names: Vec&amp;lt;String&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; args.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;().&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(create_name).collect::&amp;lt;Result&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;&amp;gt;()&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(format!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;)&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;(), names.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;join&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;,&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;)))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;signature&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Signature;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;return_type_from_exprs&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[Expr],
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn ExprSchema,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;arg_types&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[DataType],
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;DataType&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;invoke&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[ColumnarValue]) -&amp;gt; Result&amp;lt;ColumnarValue&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;simplify&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;args&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Expr&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;info&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;dyn SimplifyInfo,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;ExprSimplifyResult&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(ExprSimplifyResult::Original(args))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;short_circuits&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;false
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;evaluate_bounds&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;input&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interval]) -&amp;gt; Result&amp;lt;Interval&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Interval::make_unbounded(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;DataType::Null)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;propagate_constraints&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;interval&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interval,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;inputs&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;Interval],
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Option&amp;lt;Vec&amp;lt;Interval&amp;gt;&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(Some(vec![]))
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;output_ordering&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;inputs&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[ExprProperties]) -&amp;gt; Result&amp;lt;SortProperties&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(SortProperties::Unordered)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;coerce_types&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;arg_types&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[DataType]) -&amp;gt; Result&amp;lt;Vec&amp;lt;DataType&amp;gt;&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        not_impl_err!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;Function {} does not implement coerce_types&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;fn-as-any-self-dyn-any&quot;&gt;&lt;code&gt;fn as_any(&amp;amp;self) -&amp;gt; &amp;amp;dyn Any&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回 Any 动态类型。&lt;&#x2F;p&gt;
&lt;p&gt;可以在运行时通过类型来判断函数具体是哪种，比如 &lt;code&gt;func.as_any().downcast_ref::&amp;lt;LogFunc&amp;gt;().is_some()&lt;&#x2F;code&gt; 来判断是否为 &lt;code&gt;LogFunc&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-name-self-str&quot;&gt;&lt;code&gt;fn name(&amp;amp;self) -&amp;gt; &amp;amp;str&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回函数名称，如 &lt;code&gt;abs&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;函数名称会被作为函数唯一标识注册到 &lt;code&gt;FunctionRegistry&lt;&#x2F;code&gt; 中。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-aliases-self-string&quot;&gt;&lt;code&gt;fn aliases(&amp;amp;self) -&amp;gt; &amp;amp;[String]&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回函数的所有别名。&lt;&#x2F;p&gt;
&lt;p&gt;每个别名也会作为唯一标识注册 &lt;code&gt;FunctionRegistry&lt;&#x2F;code&gt; 中，其对应的均是同一个 UDF 实例。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-display-name-self-args-expr-result-string&quot;&gt;&lt;code&gt;fn display_name(&amp;amp;self, args: &amp;amp;[Expr]) -&amp;gt; Result&amp;lt;String&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回展示名称，包含函数名和参数，如 &lt;code&gt;abs(t1.a)&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;在打印逻辑计划、生成列名等情况均会用到。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-signature-self-signature&quot;&gt;&lt;code&gt;fn signature(&amp;amp;self) -&amp;gt; &amp;amp;Signature&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回函数入参类型和易变性（Volatility）&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;入参类型支持固定、变长参数、任意参数等等，还可以在运行时指定参数（使用 &lt;code&gt;coerce_types&lt;&#x2F;code&gt; 方法）&lt;&#x2F;li&gt;
&lt;li&gt;易变性包括三种，主要用在判断是否为常量表达式时，比如 &lt;code&gt;abs(10)&lt;&#x2F;code&gt;，可以直接在 planning 期间进行求值
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Immutable&lt;&#x2F;code&gt;：给定输入只会有一种输出，比如 &lt;code&gt;abs(num)&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Stable&lt;&#x2F;code&gt;：给定输入，在同一查询内只会有一种输出，但在不同查询间可能会有不同的输出，比如 &lt;code&gt;current_time()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Volatile&lt;&#x2F;code&gt;：每次执行时均可能产生不同的输出，比如 &lt;code&gt;random()&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;fn-return-type-from-exprs-self-args-expr-schema-dyn-exprschema-arg-types-datatype-result-datatype&quot;&gt;&lt;code&gt;fn return_type_from_exprs(&amp;amp;self, args: &amp;amp;[Expr], schema: &amp;amp;dyn ExprSchema, arg_types: &amp;amp;[DataType]) -&amp;gt; Result&amp;lt;DataType&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回函数的返回类型。&lt;&#x2F;p&gt;
&lt;p&gt;返回类型可能是动态变化的，比如 &lt;code&gt;arrow_cast(x, &#x27;Int16&#x27;)&lt;&#x2F;code&gt; 和 &lt;code&gt;arrow_cast(x, &#x27;Float32&#x27;)&lt;&#x2F;code&gt; 会返回不同的类型。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-invoke-self-args-columnarvalue-result-columnarvalue&quot;&gt;&lt;code&gt;fn invoke(&amp;amp;self, args: &amp;amp;[ColumnarValue]) -&amp;gt; Result&amp;lt;ColumnarValue&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;调用函数，返回执行结果。&lt;&#x2F;p&gt;
&lt;p&gt;因为是向量化执行，输入的是每个参数列的 Array（包含多行），返回结果列的 Array，行数量必须跟参数的行数量一致。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-simplify-self-args-vec-expr-info-dyn-simplifyinfo-result-exprsimplifyresult&quot;&gt;&lt;code&gt;fn simplify(&amp;amp;self, args: Vec&amp;lt;Expr&amp;gt;, info: &amp;amp;dyn SimplifyInfo) -&amp;gt; Result&amp;lt;ExprSimplifyResult&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;根据输入参数的表达式，来进行表达式简化。&lt;&#x2F;p&gt;
&lt;p&gt;比如 &lt;code&gt;current_time()&lt;&#x2F;code&gt;会简化成一个字面量表达式。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-short-circuits-self-bool&quot;&gt;&lt;code&gt;fn short_circuits(&amp;amp;self) -&amp;gt; bool&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;返回函数是否&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Short-circuit_evaluation&quot;&gt;短路&lt;&#x2F;a&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;短路是指在求值时，只要最终的结果已经可以确定，求值过程便告终止。比如 OR 逻辑运算符，只要有一个条件为 true，就会停止后续求值。因此短路表达式对计算顺序是有要求的。&lt;&#x2F;p&gt;
&lt;p&gt;在&lt;a href=&quot;https:&#x2F;&#x2F;en.wikipedia.org&#x2F;wiki&#x2F;Common_subexpression_elimination&quot;&gt;公共子表达式消除&lt;&#x2F;a&gt;优化中，如果函数是短路的，则会跳过不做优化。&lt;&#x2F;p&gt;
&lt;p&gt;比如在如下 SQL 中（已做简化，原例子参考&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;issues&#x2F;8814&quot;&gt;issue-8848&lt;&#x2F;a&gt;），&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;select 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case when&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt; c &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;end&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;case when&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;and&lt;&#x2F;span&gt;&lt;span&gt; b &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;then&lt;&#x2F;span&gt;&lt;span&gt; c &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&#x2F;&lt;&#x2F;span&gt;&lt;span&gt; a &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;0 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;end
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;from&lt;&#x2F;span&gt;&lt;span&gt; t;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;公共子表达式消除优化时，会把公共子表达式 &lt;code&gt;c &#x2F; a&lt;&#x2F;code&gt; 提取出来提前计算，从而导致除零错误。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-evaluate-bounds-self-input-interval-result-interval&quot;&gt;&lt;code&gt;fn evaluate_bounds(&amp;amp;self, input: &amp;amp;[&amp;amp;Interval]) -&amp;gt; Result&amp;lt;Interval&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;根据子表达式是输入区间，计算函数的输出区间。&lt;&#x2F;p&gt;
&lt;p&gt;比如 &lt;code&gt;abs(a)&lt;&#x2F;code&gt; 的子表达式 &lt;code&gt;a&lt;&#x2F;code&gt; 的区间为 &lt;code&gt;[-3, 2]&lt;&#x2F;code&gt;，则输出区间为 &lt;code&gt;[0, 3]&lt;&#x2F;code&gt;。默认实现返回无穷的区间。&lt;&#x2F;p&gt;
&lt;p&gt;在 Filter 算子中，会根据谓词和输入算子的统计数据，计算列的边界值（min&#x2F;max&#x2F;distinct_count），根据前后变化计算选择率（selectivity）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-propagate-constraints-self-interval-interval-inputs-interval-result-option-vec-interval&quot;&gt;&lt;code&gt;fn propagate_constraints(&amp;amp;self, interval: &amp;amp;Interval, inputs: &amp;amp;[&amp;amp;Interval]) -&amp;gt; Result&amp;lt;Option&amp;lt;Vec&amp;lt;Interval&amp;gt;&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;根据自身的输出区间，以及子表达式的区间，重新计算子表达式的可能区间（被进一步缩小）。&lt;&#x2F;p&gt;
&lt;p&gt;比如 &lt;code&gt;abs(num)&lt;&#x2F;code&gt; 自身输出区间为 &lt;code&gt;[4, 5]&lt;&#x2F;code&gt;，而子表达式区间为 &lt;code&gt;[-7, 3]&lt;&#x2F;code&gt;，可以计算出子表达式只能在 &lt;code&gt;[-5, 3]&lt;&#x2F;code&gt; 区间内。&lt;&#x2F;p&gt;
&lt;p&gt;在 Filter 算子中，谓词的取值区间在 &lt;code&gt;[true, true]&lt;&#x2F;code&gt;，会以此为限制区间向下传播，更新每个子表达式的取值区间。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-output-ordering-self-inputs-exprproperties-result-sortproperties&quot;&gt;&lt;code&gt;fn output_ordering(&amp;amp;self, inputs: &amp;amp;[ExprProperties]) -&amp;gt; Result&amp;lt;SortProperties&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;根据子表达式的排序属性，返回输出的排序属性。&lt;&#x2F;p&gt;
&lt;p&gt;比如 &lt;code&gt;cos(num)&lt;&#x2F;code&gt; 输出的排序属性是 &lt;code&gt;Unordered&lt;&#x2F;code&gt;，&lt;code&gt;radians(num)&lt;&#x2F;code&gt;（将度数转为弧度）输出的排序属性跟输入保持一致，即为 &lt;code&gt;input[0].sort_properties&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;这些排序属性会作为等价属性（EquivalenceProperties）一部分，在 Join、Sort 等优化中使用。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;fn-coerce-types-self-arg-types-datatype-result-vec-datatype&quot;&gt;&lt;code&gt;fn coerce_types(&amp;amp;self, arg_types: &amp;amp;[DataType]) -&amp;gt; Result&amp;lt;Vec&amp;lt;DataType&amp;gt;&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;对于入参类型为用户自定义类型时，在运行时拿到实际入参类型，返回需要强制转换后的入参类型。&lt;&#x2F;p&gt;
&lt;p&gt;DataFusion 会将入参强制转换为这些类型，然后再执行 UDF 的 &lt;code&gt;invoke&lt;&#x2F;code&gt; 方法。&lt;&#x2F;p&gt;
&lt;p&gt;比如 &lt;code&gt;make_array(expression1[, ..., expression_n])&lt;&#x2F;code&gt; 会找出入参类型中最大的类型，然后将每个入参强制转换为此类型。例如 &lt;code&gt;make_array(1, 2.2)&lt;&#x2F;code&gt; 会将每个入参转换为 &lt;code&gt;Float64&lt;&#x2F;code&gt; 类型。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;udf-ru-he-xu-lie-hua-he-fan-xu-lie-hua&quot;&gt;UDF 如何序列化和反序列化？&lt;&#x2F;h2&gt;
&lt;p&gt;在分布式下，需要通过网络将执行计划传给其他节点执行，其中需要对 UDF 进行序列化和反序列化。&lt;&#x2F;p&gt;
&lt;p&gt;DataFusion 提供了两种方式对 UDF 进行序列化和反序列化&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;只传输 UDF 名称，在反序列化时从 &lt;code&gt;FunctionRegistry&lt;&#x2F;code&gt; 通过名称拿到实际的 UDF，这需要 UDF 在两个节点上的 &lt;code&gt;FunctionRegistry&lt;&#x2F;code&gt; 均被注册&lt;&#x2F;li&gt;
&lt;li&gt;用户自定义 UDF 序列化和反序列化方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;DataFusion 会优先使用用户自定义的序列化和反序列化方法，如果用户未实现，则 fallback 到使用 UDF 名称方案。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>DataFusion 查询引擎 TreeNode APIs</title>
		<published>2024-05-23T00:00:00+00:00</published>
		<updated>2024-05-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-tree-node-apis/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-tree-node-apis/</id>
		<content type="html">&lt;p&gt;数据库系统中有很多树形数据结构（如逻辑计划、表达式、物理计划），经常需要对这些树形结构遍历来进行检查（Inspecting）或者变换（Transforming），因此设计一个好的 API 可以事半功倍。DataFusion 中的 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;datafusion&#x2F;38.0.0&#x2F;datafusion&#x2F;common&#x2F;tree_node&#x2F;trait.TreeNode.html&quot;&gt;TreeNode APIs&lt;&#x2F;a&gt; 设计具有很好的扩展性，其中的具体实现巧妙地利用了多种递归技巧，非常值得研究。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;di-ceng-api&quot;&gt;底层 API&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TreeNode: Sized {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_children&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt;, F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_children&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub enum &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion {
&lt;&#x2F;span&gt;&lt;span&gt;    Continue,
&lt;&#x2F;span&gt;&lt;span&gt;    Jump,
&lt;&#x2F;span&gt;&lt;span&gt;    Stop,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;Transformed&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;data&lt;&#x2F;span&gt;&lt;span&gt;: T,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;transformed&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;bool&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tnr&lt;&#x2F;span&gt;&lt;span&gt;: TreeNodeRecursion,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;这是两个底层 API，主要用来实现其他更高级的 API。而且它没有默认实现，因此必须手动实现。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apply_children&lt;&#x2F;code&gt; 接收一个 f 函数，将 f 函数应用到其每个子节点上，对每个子节点进行检查，直至 f 函数在某个子节点上返回 &lt;code&gt;TreeNodeRecursion::Stop&lt;&#x2F;code&gt; 指令，最终返回最后一次 f 函数执行的结果&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;map_children&lt;&#x2F;code&gt; 接收一个 f 函数，将 f 函数应用到其每个子节点上，对每个子节点进行变换，直至 f 函数在某个子节点上返回 &lt;code&gt;TreeNodeRecursion::Stop&lt;&#x2F;code&gt; 指令，最终返回更新后的父节点&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;jian-cha-api&quot;&gt;检查 API&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TreeNode: Sized {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt;, F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt;, N: TreeNode, F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt; N) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt; N,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; F,
&lt;&#x2F;span&gt;&lt;span&gt;        ) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(node)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_children&lt;&#x2F;span&gt;&lt;span&gt;(|| node.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_children&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_impl&lt;&#x2F;span&gt;&lt;span&gt;(c, f)))
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_impl&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; f)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;visit_children&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnOnce() -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            TreeNodeRecursion::Continue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;(),
&lt;&#x2F;span&gt;&lt;span&gt;            TreeNodeRecursion::Jump &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(TreeNodeRecursion::Continue),
&lt;&#x2F;span&gt;&lt;span&gt;            TreeNodeRecursion::Stop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;apply&lt;&#x2F;code&gt; API 接收一个 f 函数，从当前节点开始自上而下前序遍历（根左右）整个树，对每个节点应用 f 函数进行检查。&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;TreeNodeRecursion::visit_children&lt;&#x2F;code&gt; 方法中，接收一个 c 闭包函数来遍历所有子节点&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Continue&lt;&#x2F;code&gt; 指令，则执行 c 来遍历子节点&lt;&#x2F;li&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Jump&lt;&#x2F;code&gt; 指令，则跳过整个子树遍历，继续遍历其兄弟节点&lt;&#x2F;li&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Stop&lt;&#x2F;code&gt; 指令，则直接停止整个树遍历（Stop 指令会向下传递）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-tree-node-apis&#x2F;.&#x2F;datafusion-treenode-apply.drawio.png&quot; alt=&quot;apply-api&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;bian-huan-api&quot;&gt;变换 API&lt;&#x2F;h2&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;TreeNode: Sized {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_down&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_down_impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;N: TreeNode, F: FnMut(N) -&amp;gt; Result&amp;lt;Transformed&amp;lt;N&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;: N,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; F,
&lt;&#x2F;span&gt;&lt;span&gt;        ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;N&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(node)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_children&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;n&lt;&#x2F;span&gt;&lt;span&gt;| n.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_children&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_down_impl&lt;&#x2F;span&gt;&lt;span&gt;(c, f)))
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_down_impl&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; f)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_up&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_up_impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;N: TreeNode, F: FnMut(N) -&amp;gt; Result&amp;lt;Transformed&amp;lt;N&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;: N,
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; F,
&lt;&#x2F;span&gt;&lt;span&gt;        ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;N&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;            node.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_children&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;c&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_up_impl&lt;&#x2F;span&gt;&lt;span&gt;(c, f))&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?
&lt;&#x2F;span&gt;&lt;span&gt;                .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_parent&lt;&#x2F;span&gt;&lt;span&gt;(f)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_up_impl&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;mut&lt;&#x2F;span&gt;&lt;span&gt; f)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;T&amp;gt; Transformed&amp;lt;T&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_parent&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnOnce(T) -&amp;gt; Result&amp;lt;Transformed&amp;lt;T&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;T&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.tnr {
&lt;&#x2F;span&gt;&lt;span&gt;            TreeNodeRecursion::Continue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.data).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;t&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;                t.transformed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;|= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.transformed;
&lt;&#x2F;span&gt;&lt;span&gt;                t
&lt;&#x2F;span&gt;&lt;span&gt;            }),
&lt;&#x2F;span&gt;&lt;span&gt;            TreeNodeRecursion::Jump &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion::Stop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;),
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;transform_down&lt;&#x2F;code&gt; API 接收一个 f 函数，从当前节点开始自上而下前序遍历（根左右）整个树，对每个节点应用 f 函数进行变换，返回新的树。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;transform_up&lt;&#x2F;code&gt; API 接收一个 f 函数，自下而上后序遍历（左右根）整个树直至当前节点，对每个节点应用 f 函数进行变换，返回新的树。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;code&gt;transform_down&lt;&#x2F;code&gt; 实现跟 &lt;code&gt;apply&lt;&#x2F;code&gt; API 实现类似，这里主要说下 &lt;code&gt;transform_up&lt;&#x2F;code&gt; 实现。&lt;&#x2F;p&gt;
&lt;p&gt;在 &lt;code&gt;Transformed::transform_parent&lt;&#x2F;code&gt; 方法中，接收一个 f 函数来对当前节点进行变换&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Continue&lt;&#x2F;code&gt; 指令，则应用 f 函数给当前节点&lt;&#x2F;li&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Jump&lt;&#x2F;code&gt; 指令，则跳过后续所有非叶节点，直至遇到叶节点开始继续遍历（在叶节点执行 &lt;code&gt;map_children&lt;&#x2F;code&gt; 会返回 &lt;code&gt;TreeNodeRecursion::Continue&lt;&#x2F;code&gt; 指令）&lt;&#x2F;li&gt;
&lt;li&gt;如果是 &lt;code&gt;TreeNodeRecursion::Stop&lt;&#x2F;code&gt; 指令，则直接停止整个树遍历（Stop 指令会向上传递）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-tree-node-apis&#x2F;.&#x2F;datafusion-treenode-transform_up.drawio.png&quot; alt=&quot;transform_up-api&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;yan-zheng&quot;&gt;验证&lt;&#x2F;h2&gt;
&lt;p&gt;自定义树节点并实现 &lt;a href=&quot;https:&#x2F;&#x2F;docs.rs&#x2F;datafusion&#x2F;38.0.0&#x2F;datafusion&#x2F;common&#x2F;tree_node&#x2F;trait.TreeNode.html&quot;&gt;TreeNode APIs&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 依赖 datafusion = { git = &amp;quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion.git&amp;quot;, rev = &amp;quot;100b30e13583badc5aa9e88861d63feb80876c5e&amp;quot; }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;struct &lt;&#x2F;span&gt;&lt;span&gt;MyNode {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;no&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;i32&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;children&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;MyNode&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;TreeNode &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyNode {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply_children&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;#39;n&lt;&#x2F;span&gt;&lt;span&gt;, F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&amp;#39;n &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;TreeNodeRecursion, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tnr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion::Continue;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for&lt;&#x2F;span&gt;&lt;span&gt; node &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;in &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.children.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;iter&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;            tnr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(node)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;?&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; tnr {
&lt;&#x2F;span&gt;&lt;span&gt;                TreeNodeRecursion::Continue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion::Jump &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;{}
&lt;&#x2F;span&gt;&lt;span&gt;                TreeNodeRecursion::Stop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; return &lt;&#x2F;span&gt;&lt;span&gt;Ok(TreeNodeRecursion::Stop),
&lt;&#x2F;span&gt;&lt;span&gt;            }
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(tnr)
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map_children&lt;&#x2F;span&gt;&lt;span&gt;&amp;lt;F: FnMut(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;&amp;gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;: F,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Transformed&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;Self&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; tnr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion::Continue;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let mut&lt;&#x2F;span&gt;&lt;span&gt; transformed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;false&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.children
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_iter&lt;&#x2F;span&gt;&lt;span&gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;item&lt;&#x2F;span&gt;&lt;span&gt;| &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;match&lt;&#x2F;span&gt;&lt;span&gt; tnr {
&lt;&#x2F;span&gt;&lt;span&gt;                TreeNodeRecursion::Continue &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;| &lt;&#x2F;span&gt;&lt;span&gt;TreeNodeRecursion::Jump &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;f&lt;&#x2F;span&gt;&lt;span&gt;(item).&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;result&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;                    tnr &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; result.tnr;
&lt;&#x2F;span&gt;&lt;span&gt;                    transformed &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;|=&lt;&#x2F;span&gt;&lt;span&gt; result.transformed;
&lt;&#x2F;span&gt;&lt;span&gt;                    result.data
&lt;&#x2F;span&gt;&lt;span&gt;                }),
&lt;&#x2F;span&gt;&lt;span&gt;                TreeNodeRecursion::Stop &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&amp;gt; &lt;&#x2F;span&gt;&lt;span&gt;Ok(item),
&lt;&#x2F;span&gt;&lt;span&gt;            })
&lt;&#x2F;span&gt;&lt;span&gt;            .collect::&amp;lt;Result&amp;lt;Vec&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;_&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;, DataFusionError&amp;gt;&amp;gt;()
&lt;&#x2F;span&gt;&lt;span&gt;            .&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;map&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;new_children&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;                Transformed::new(
&lt;&#x2F;span&gt;&lt;span&gt;                    MyNode {
&lt;&#x2F;span&gt;&lt;span&gt;                        no: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.no,
&lt;&#x2F;span&gt;&lt;span&gt;                        children: new_children,
&lt;&#x2F;span&gt;&lt;span&gt;                    },
&lt;&#x2F;span&gt;&lt;span&gt;                    transformed,
&lt;&#x2F;span&gt;&lt;span&gt;                    tnr,
&lt;&#x2F;span&gt;&lt;span&gt;                )
&lt;&#x2F;span&gt;&lt;span&gt;            })
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;构建一棵树&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;        1
&lt;&#x2F;span&gt;&lt;span&gt;        2
&lt;&#x2F;span&gt;&lt;span&gt;    3       4
&lt;&#x2F;span&gt;&lt;span&gt;  5   6   7   8
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;测试 &lt;code&gt;apply&lt;&#x2F;code&gt; API&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_apply&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; root &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;build_tree&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;apply&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;accessed node: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, node.no);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; node.no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;3 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(TreeNodeRecursion::Jump)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; node.no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;7 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(TreeNodeRecursion::Stop)
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(TreeNodeRecursion::Continue)
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 输出
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; accessed node: 1
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; accessed node: 2
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; accessed node: 3
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; accessed node: 4
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; accessed node: 7
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;测试 &lt;code&gt;transform_up&lt;&#x2F;code&gt; API&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;test&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;test_transform_up&lt;&#x2F;span&gt;&lt;span&gt;() {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; root &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;build_tree&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;span&gt;    root.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;transform_up&lt;&#x2F;span&gt;&lt;span&gt;(|&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;mut &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;node&lt;&#x2F;span&gt;&lt;span&gt;| {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; old_no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; node.no;
&lt;&#x2F;span&gt;&lt;span&gt;        node.no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; old_no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;* &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;10&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span&gt;        println!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;transformed node: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt; -&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;{}&lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;, old_no, node.no);
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if&lt;&#x2F;span&gt;&lt;span&gt; old_no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(Transformed::new(node, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, TreeNodeRecursion::Stop))
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else if&lt;&#x2F;span&gt;&lt;span&gt; old_no &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;== &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;6 &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(Transformed::new(node, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, TreeNodeRecursion::Jump))
&lt;&#x2F;span&gt;&lt;span&gt;        } &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;else &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            Ok(Transformed::new(node, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;true&lt;&#x2F;span&gt;&lt;span&gt;, TreeNodeRecursion::Continue))
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    });
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 输出
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 5 -&amp;gt; 50
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 6 -&amp;gt; 60
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 7 -&amp;gt; 70
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 8 -&amp;gt; 80
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 4 -&amp;gt; 40
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; transformed node: 2 -&amp;gt; 20
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Apache DataFusion 查询引擎论文</title>
		<published>2024-05-10T00:00:00+00:00</published>
		<updated>2024-05-10T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/datafusion-paper/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/datafusion-paper/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;.&#x2F;apache-datafusion-query-engine.pdf&quot;&gt;论文&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-shao&quot;&gt;介绍&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;datafusion.apache.org&#x2F;&quot;&gt;DataFusion&lt;&#x2F;a&gt; 是一个 &lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt; 语言编写的、快速的、可嵌入的和可扩展的分析查询引擎，采用 &lt;a href=&quot;https:&#x2F;&#x2F;arrow.apache.org&#x2F;&quot;&gt;Apache Arrow&lt;&#x2F;a&gt; 作为它的内存数据格式。本论文主要描述它采用的技术以及如何适应如今数据库模块化的趋势，然后列举了其功能、优化、架构和扩展 API，最后通过与 &lt;a href=&quot;https:&#x2F;&#x2F;duckdb.org&#x2F;&quot;&gt;DuckDB&lt;&#x2F;a&gt; 比较来表明使用开放标准和可扩展性的设计并不会影响性能。&lt;&#x2F;p&gt;
&lt;p&gt;传统上，高性能分析查询引擎领域一直由紧密集成的系统主导（如 &lt;a href=&quot;https:&#x2F;&#x2F;www.vertica.com&#x2F;&quot;&gt;Vertica&lt;&#x2F;a&gt;、&lt;a href=&quot;https:&#x2F;&#x2F;spark.apache.org&#x2F;&quot;&gt;Spark&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;duckdb.org&#x2F;&quot;&gt;DuckDB&lt;&#x2F;a&gt;）。在如今机器学习等新需求催动下，重复造轮子开发新引擎人力昂贵且没有必要。DataFusion 具有竞争力的性能和可扩展性表明，现代 OLAP 引擎不需要一个紧密结合的架构。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ji-chu-sheng-tai&quot;&gt;基础生态&lt;&#x2F;h2&gt;
&lt;p&gt;DataFusion 构建在以下基础技术之上&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;arrow.apache.org&#x2F;&quot;&gt;Apache Arrow&lt;&#x2F;a&gt;：高效的列式内存数据格式，并提供一个高性能的计算核心&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;parquet.apache.org&#x2F;&quot;&gt;Apache Parquet&lt;&#x2F;a&gt;：列式存储文件格式，高效压缩和编码，内嵌 Schema，支持索引，支持 projection 和 filter 下推&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.rust-lang.org&#x2F;&quot;&gt;Rust&lt;&#x2F;a&gt;：新的系统编程语言，内存安全，高性能，易嵌入其他系统（无 Runtime，C ABI 兼容），生态丰富，开发者友好（工具链，Cargo 包管理）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;DataFusion 采用这些开放标准的技术，使其更容易与其他系统集成（直接可分享的文件和内存数据交换）。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shi-yong-an-li&quot;&gt;使用案例&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;定制数据库：如时序领域 &lt;a href=&quot;https:&#x2F;&#x2F;www.influxdata.com&#x2F;&quot;&gt;InfluxDB&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;coralogix.com&#x2F;&quot;&gt;Coralogix&lt;&#x2F;a&gt;，流数据处理 &lt;a href=&quot;https:&#x2F;&#x2F;www.synnada.ai&#x2F;&quot;&gt;Synnada&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;www.arroyo.dev&#x2F;&quot;&gt;Arroyo&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;执行引擎：如作为 Spark 的执行引擎 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-comet&quot;&gt;Comet&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kwai&#x2F;blaze&quot;&gt;Blaze&lt;&#x2F;a&gt;，作为 PostgreSQL 的执行引擎 &lt;a href=&quot;https:&#x2F;&#x2F;seafowl.io&#x2F;&quot;&gt;Seafowl&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;SQL 分析工具：如 &lt;a href=&quot;https:&#x2F;&#x2F;dask-sql.readthedocs.io&#x2F;en&#x2F;latest&#x2F;&quot;&gt;dask-sql&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;表格式：如 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;delta-io&#x2F;delta-rs&quot;&gt;Delta Lake&lt;&#x2F;a&gt;、&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;iceberg-rust&quot;&gt;Apache Iceberg&lt;&#x2F;a&gt; 和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lancedb&#x2F;lance&quot;&gt;Lance&lt;&#x2F;a&gt; 来用 DataFusion 来拉取和解码远端数据、谓词下推等&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;使用 DataFusion 可以不必重复造轮子，将人力放到更有价值的功能上面。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;shu-ju-ku-mo-kuai-hua&quot;&gt;数据库模块化&lt;&#x2F;h2&gt;
&lt;p&gt;数据库一个长期趋势是从“one size fits all”通用系统逐渐转向“fit for purpose”专用系统，因此诞生了 &lt;a href=&quot;https:&#x2F;&#x2F;calcite.apache.org&#x2F;&quot;&gt;Apache Calcite&lt;&#x2F;a&gt;、&lt;a href=&quot;https:&#x2F;&#x2F;velox-lib.io&#x2F;&quot;&gt;Velox&lt;&#x2F;a&gt; 和本项目。&lt;&#x2F;p&gt;
&lt;p&gt;类似于编译领域的 LLVM，模块化的设计催生出了 Rust、Swift、Zig 和 Julia 等语言。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;datafusion-gong-neng-jie-shao&quot;&gt;DataFusion 功能介绍&lt;&#x2F;h2&gt;
&lt;img src=&quot;datafusion-architecture.png&quot; alt=&quot;datafusion-architecture&quot; width=&quot;800&quot;&#x2F;&gt;
&lt;p&gt;DataFusion 的模块化实现遵循业界最佳实践&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Catalog 和 Data Sources：提供 schema、数据布局和位置信息。支持 parquet&#x2F;avro&#x2F;json&#x2F;csv 等格式开箱即用&lt;&#x2F;li&gt;
&lt;li&gt;Front End：负责创建逻辑计划。支持 SQL 同时还提供了 DataFrame 和 LogicalPlanBuilder API&lt;&#x2F;li&gt;
&lt;li&gt;Optimizer：优化逻辑计划和表达式&lt;&#x2F;li&gt;
&lt;li&gt;PhysicalPlanner：将逻辑计划转为物理计划&lt;&#x2F;li&gt;
&lt;li&gt;PhysicalOptimizer：基于数据布局等信息优化物理计划&lt;&#x2F;li&gt;
&lt;li&gt;物理计划采用流式执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;DataFusion 支持 Protobuf 和 Substrait 来序列化和反序列化逻辑计划和物理计划。&lt;&#x2F;p&gt;
&lt;p&gt;DataFusion 内置的开箱即用功能（如优化规则、用户自定义函数、Datasource）和用户扩展均使用同一个 API 实现。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhi-xing-yin-qing&quot;&gt;执行引擎&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;impl &lt;&#x2F;span&gt;&lt;span&gt;Stream &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;for &lt;&#x2F;span&gt;&lt;span&gt;MyOperator {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 拉取下一次输入（可能在 await 处 yield）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;while let &lt;&#x2F;span&gt;&lt;span&gt;Some(batch) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; stream.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;next&lt;&#x2F;span&gt;&lt;span&gt;().await {
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; 计算，检查输出是否准备就绪
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;if &lt;&#x2F;span&gt;&lt;span&gt;Some(output) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;process&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;batch)&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;? &lt;&#x2F;span&gt;&lt;span&gt;{
&lt;&#x2F;span&gt;&lt;span&gt;            &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F; “返回” RecordBatch 给输出 
&lt;&#x2F;span&gt;&lt;span&gt;            tx.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;send&lt;&#x2F;span&gt;&lt;span&gt;(batch).await
&lt;&#x2F;span&gt;&lt;span&gt;        }
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;...
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;DataFusion 采用基于 Pull 的流式执行引擎。物理计划使用一个或多个 Stream 来并行执行，而 Stream 采用 Rust 异步实现并通过 Tokio 调度，达到了跟 &lt;a href=&quot;https:&#x2F;&#x2F;dl.acm.org&#x2F;doi&#x2F;pdf&#x2F;10.1145&#x2F;2588555.2610507&quot;&gt;Morsel-driven parallelism: a NUMA-aware query evaluation framework for the many-core age&lt;&#x2F;a&gt; 论文类似的伸缩能力。&lt;&#x2F;p&gt;
&lt;img src=&quot;partitioned-execution.png&quot; alt=&quot;partitioned-execution&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;h2 id=&quot;you-hua&quot;&gt;优化&lt;&#x2F;h2&gt;
&lt;p&gt;内置实现了业界广泛使用的优化&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;查询重写：逻辑计划重写如谓词下推、表达式简化，物理计划重写如消除不必要排序、最大化并行度、join算法选择&lt;&#x2F;li&gt;
&lt;li&gt;排序：如针对 Limit（topk）优化，内存不足时临时写入磁盘&lt;&#x2F;li&gt;
&lt;li&gt;分组和聚合优化：两阶段并行哈希分组聚合&lt;&#x2F;li&gt;
&lt;li&gt;连接：支持 hash join &#x2F; merge join &#x2F; symmetric hash join &#x2F; nested loops join &#x2F; cross join&lt;&#x2F;li&gt;
&lt;li&gt;窗口函数：复用排序、支持流式计算&lt;&#x2F;li&gt;
&lt;li&gt;Normalized Sort Keys &#x2F; RowFormat&lt;&#x2F;li&gt;
&lt;li&gt;有效利用排序顺序&lt;&#x2F;li&gt;
&lt;li&gt;下推和延迟物化&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;kuo-zhan-xing&quot;&gt;扩展性&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;用户自定义函数：标量&#x2F;聚合&#x2F;窗口&lt;&#x2F;li&gt;
&lt;li&gt;Catalog：TableProvider 表示一张表，SchemaProvider 是包含多个 TableProvider 的集合，CatalogProvider 是包含多个 SchemaProviders 的集合&lt;&#x2F;li&gt;
&lt;li&gt;Data Source：使用 TableProvider 表示，支持分区输入、谓词&#x2F;filter&#x2F;limit下推、预排序、统计信息等&lt;&#x2F;li&gt;
&lt;li&gt;Execution Environment：提供了 MemoryPool、DiskManager、CacheManager 等支持执行中临时写入磁盘、算子间共享资源&lt;&#x2F;li&gt;
&lt;li&gt;新的查询前端&lt;&#x2F;li&gt;
&lt;li&gt;查询重写：包括逻辑计划和物理计划&lt;&#x2F;li&gt;
&lt;li&gt;关系运算符：使用 ExecutionPlan 来扩展新的运算符&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;用户均可扩展以上功能。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xing-neng-ping-gu&quot;&gt;性能评估&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;单核执行&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;TPC-H&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-paper&#x2F;tpch-benchmark.png&quot; alt=&quot;tpch&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;H2O-G&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;datafusion-paper&#x2F;h2og-benchmark.png&quot; alt=&quot;h2og&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;使用开放标准技术并不会从根本上限制 DataFusion 的性能，而且 DataFusion 社区正在针对这些 benchmark 做优化。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;多核执行&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;ClickBench&lt;&#x2F;p&gt;
&lt;img src=&quot;multi-cores-benchmark.png&quot; alt=&quot;multi-cores-benchmark&quot; width=&quot;800&quot;&#x2F;&gt;
&lt;p&gt;DataFusion 的模块化设计和 Pull-based 执行引擎并不会阻碍其获取最先进的多核性能。DataFusion 在多核上具有很好的伸缩性。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jie-lun&quot;&gt;结论&lt;&#x2F;h2&gt;
&lt;p&gt;自从引入 LLVM 以来，从头开始构建编译器的需求已显著减少。随着 DataFusion 等技术的出现，从头开始构建数据库系统的需求也将变得同样罕见。当然，如果有足够的工程投资，紧密集成的引擎理论上可以胜过模块化引擎。然而，随着实现最先进功能和性能的成本不断增加，我们相信广泛使用的模块化引擎（例如 DataFusion）将吸引大型开源社区的投资，逐渐提供更丰富的功能集和除了拥有大量资源的紧密集成设计引擎之外的最好的性能。&lt;&#x2F;p&gt;
&lt;p&gt;模块化设计绝不是构建系统的唯一策略，我们不断看到新的紧密集成的系统的出现。然而，随着对 DataFusion 等系统的认识不断增强，我们预测会有更多项目采用模块化引擎，新的分析系统将会出现爆炸式增长，这在以前是不可能的。&lt;&#x2F;p&gt;
&lt;p&gt;注：论文标题为 Apache Arrow DataFusion 是因为在写论文时，&lt;a href=&quot;https:&#x2F;&#x2F;datafusion.apache.org&#x2F;&quot;&gt;DataFusion&lt;&#x2F;a&gt; 是 &lt;a href=&quot;https:&#x2F;&#x2F;arrow.apache.org&#x2F;&quot;&gt;Apache Arrow&lt;&#x2F;a&gt; 项目下的一个子项目，而如今 &lt;a href=&quot;https:&#x2F;&#x2F;datafusion.apache.org&#x2F;&quot;&gt;DataFusion&lt;&#x2F;a&gt; 已升级为 Apache 顶级项目。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ballista 分布式查询引擎 - 计划执行</title>
		<published>2024-04-27T00:00:00+00:00</published>
		<updated>2024-04-27T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/ballista-mvp-part5/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/ballista-mvp-part5/</id>
		<content type="html">&lt;p&gt;所有计划的执行均由 Executor 节点负责。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;ballista-mvp-part5&#x2F;.&#x2F;ballista-mvp-executor.drawio.png&quot; alt=&quot;ballista-mvp-executor&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Executor 节点启动时&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;启动 ExecutorGrpc 服务，负责接收 Scheduler 节点发送的任务和其他指令&lt;&#x2F;li&gt;
&lt;li&gt;启动 Flight 服务，Client 和其他 Executor 通过 Flight 协议读取本机执行结果数据&lt;&#x2F;li&gt;
&lt;li&gt;向 Scheduler 注册（id&#x2F;ip&#x2F;port、计算资源总量等）&lt;&#x2F;li&gt;
&lt;li&gt;启动心跳任务，定时向所有 Scheduler 节点发送心跳&lt;&#x2F;li&gt;
&lt;li&gt;启动任务执行池，负责轮询队列获取新任务并执行&lt;&#x2F;li&gt;
&lt;li&gt;启动执行状态上报任务，负责上报任务状态给 Scheduler&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;Executor 执行的基本单元是 Task，一个 Task 会执行一个 Job 内的一个 stage 对应的一个 partition。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;TaskDefinition {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 在执行图中的唯一的（单调递增）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;task_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 所属 job
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 所属 stage
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stage_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; partition
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;partition_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; stage 执行计划
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;plan&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;dyn ExecutionPlan&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; Scheduler 发起任务时间
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;launch_time&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 所属会话
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;session_id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 会话设置
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;props&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;HashMap&amp;lt;String, String&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Ballista 运行 CPU 密集型任务&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Ballista 采用 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;tokio-rs&#x2F;tokio&quot;&gt;Tokio&lt;&#x2F;a&gt; 作为 Rust 异步运行时。Tokio 使用协作式调度，异步任务会在执行到 &lt;code&gt;.await&lt;&#x2F;code&gt; 时切换其他任务执行，使用 Tokio 须遵守 &lt;code&gt;&amp;quot;Async code should never spend a long time without reaching an .await.&amp;quot;&lt;&#x2F;code&gt;（参考 Tokio maintainer 的&lt;a href=&quot;https:&#x2F;&#x2F;ryhl.io&#x2F;blog&#x2F;async-what-is-blocking&#x2F;&quot;&gt;这篇博客&lt;&#x2F;a&gt;）。因此 CPU 密集型任务会长时间占用 CPU，导致运行时上的其他任务无法被及时执行（如心跳）。&lt;&#x2F;p&gt;
&lt;p&gt;Ballista 解决此问题的办法是&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;采用单独的运行时专门跑 CPU 密集型任务&lt;&#x2F;li&gt;
&lt;li&gt;IO 密集型任务运行时与 CPU 密集型任务运行时通过队列通信（创新新任务&#x2F;任务执行结果通知）&lt;&#x2F;li&gt;
&lt;li&gt;当然 CPU 密集型任务代码仍要遵守 &lt;code&gt;&amp;quot;Async code should never spend a long time without reaching an .await.&amp;quot;&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;更多细节可参考 Datafusion maintainer 的这篇文章：&lt;a href=&quot;https:&#x2F;&#x2F;thenewstack.io&#x2F;using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks&#x2F;&quot;&gt;https:&#x2F;&#x2F;thenewstack.io&#x2F;using-rustlangs-async-tokio-runtime-for-cpu-bound-tasks&#x2F;&lt;&#x2F;a&gt; 。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ballista 分布式查询引擎 - 集群共享状态</title>
		<published>2024-04-24T00:00:00+00:00</published>
		<updated>2024-04-24T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/ballista-mvp-part4/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/ballista-mvp-part4/</id>
		<content type="html">&lt;p&gt;集群共享状态会被存储在共享 kv 中，被所有 Scheduler 节点读写。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 集群节点状态
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tonic&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;ClusterState: Send + Sync + &amp;#39;static {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 启动时初始化
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;init&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;        Ok(())
&lt;&#x2F;span&gt;&lt;span&gt;    }
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 将可执行的 tasks 分配到对应的 executor 计算资源槽上
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;bind_schedulable_tasks&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;distribution&lt;&#x2F;span&gt;&lt;span&gt;: TaskDistributionPolicy,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;active_jobs&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;HashMap&amp;lt;String, JobInfoCache&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;executors&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;HashSet&amp;lt;String&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;BoundTask&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 解绑 tasks，释放 executor 计算资源
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;unbind_tasks&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;executor_slots&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;ExecutorSlot&amp;gt;) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 注册 executor
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;register_executor&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;: ExecutorMetadata, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;spec&lt;&#x2F;span&gt;&lt;span&gt;: ExecutorData)
&lt;&#x2F;span&gt;&lt;span&gt;        -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 保存 executor 元信息
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;save_executor_metadata&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;metadata&lt;&#x2F;span&gt;&lt;span&gt;: ExecutorMetadata) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 读取 executor 元信息
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_executor_metadata&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;executor_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;ExecutorMetadata&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 保存 executor 最新心跳信息
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;save_executor_heartbeat&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;heartbeat&lt;&#x2F;span&gt;&lt;span&gt;: ExecutorHeartbeat) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 从集群中移除 executor 
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;remove_executor&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;executor_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 返回所有活跃 executor 的最新心跳信息
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;executor_heartbeats&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; HashMap&amp;lt;String, ExecutorHeartbeat&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 读取 executor 最新心跳信息
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_executor_heartbeat&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;executor_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Option&amp;lt;ExecutorHeartbeat&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 集群作业状态
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tonic&lt;&#x2F;span&gt;&lt;span&gt;::&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;JobState: Send + Sync {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 接收作业进本地队列（并没有存储在共享 kv 中）
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;accept_job&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;queued_at&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u64&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 提交作业
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;submit_job&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: String, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;graph&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExecutionGraph) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 获取所有活跃 job id
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_jobs&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;HashSet&amp;lt;String&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 获取作业状态
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_job_status&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Option&amp;lt;JobStatus&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 获取作业的执行图（分布式执行计划）
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_execution_graph&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Option&amp;lt;ExecutionGraph&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 保存作业执行图状态
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;save_job&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;graph&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;ExecutionGraph) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 标记作业失败（planning阶段失败）
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;fail_unscheduled_job&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;reason&lt;&#x2F;span&gt;&lt;span&gt;: String) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 移除作业
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;remove_job&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 读取会话
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;get_session&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;session_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;) -&amp;gt; Result&amp;lt;Arc&amp;lt;SessionContext&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 创建一个会话
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;create_session&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;config&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;BallistaConfig) -&amp;gt; Result&amp;lt;Arc&amp;lt;SessionContext&amp;gt;&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Executor 元信息&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;主要包括 Executor 的 id、ip 和 端口等信息。在 Executor 节点启动时，会往 Scheduler 注册，Scheduler 会将 Executor 元信息存储到共享 kv 中。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Executor 心跳信息&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;主要包括 Executor 的 id、此次心跳时间戳 和 executor 状态。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;在 Executor 启动注册时，会往共享 kv 中存入心跳信息&lt;&#x2F;li&gt;
&lt;li&gt;在 Executor 定时发送心跳时，会往共享 kv 中覆盖心跳信息&lt;&#x2F;li&gt;
&lt;li&gt;在检查 Executor 心跳是否过期的定时任务中，会移除共享 kv 中过期的 Executor 的心跳信息&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;Executor 资源信息&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;主要包括 Executor 还有多少计算资源（一个任务执行占据一个资源槽位）。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;在注册 executor 时，会增加资源槽位总量&lt;&#x2F;li&gt;
&lt;li&gt;在分配可执行 tasks 到 executor 时，会消耗资源槽位&lt;&#x2F;li&gt;
&lt;li&gt;在 tasks 执行完毕时，释放资源槽位&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;会话信息&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;会话信息主要包括作业配置（如配置多少并行度），Client 连接 Scheduler 时，会创建一个会话并存储在共享 kv 中。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;作业执行图（分布式执行计划）&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;主要包括整个分布式执行计划，以及每个 stage 的执行状态。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;在提交作业时，会将整个执行图保存到共享 kv 中&lt;&#x2F;li&gt;
&lt;li&gt;在作业执行成功&#x2F;终止作业&#x2F;作业执行有更新时，会更新整个执行图到共享 kv 中&lt;&#x2F;li&gt;
&lt;li&gt;在作业执行完毕后，会从共享 kv 中移除&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;作业状态&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;作业状态因为读取频繁，被额外单独存储（作业状态可以从执行图中获取）。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;在提交作业时，会将作业状态保存到共享 kv 中&lt;&#x2F;li&gt;
&lt;li&gt;在作业执行成功&#x2F;终止作业&#x2F;作业执行有更新时，会更新作业状态到共享 kv 中&lt;&#x2F;li&gt;
&lt;li&gt;在作业执行完毕后，会从共享 kv 中移除&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ballista 分布式查询引擎 - 事件驱动调度</title>
		<published>2024-04-23T00:00:00+00:00</published>
		<updated>2024-04-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/ballista-mvp-part3/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/ballista-mvp-part3/</id>
		<content type="html">&lt;p&gt;Ballista Scheduler 在调度整个 SQL 执行过程均通过事件驱动。&lt;&#x2F;p&gt;
&lt;p&gt;事件循环定义&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;EventLoop&amp;lt;E&amp;gt; {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 事件循环名称
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;name&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 有界事件队列大小
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;buffer_size&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 事件循环停止信号
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stopped&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;AtomicBool&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 根据事件执行对应动作
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;action&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;dyn EventAction&amp;lt;E&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 事件队列生产者
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tx_event&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;mpsc::Sender&amp;lt;E&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;#[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;async_trait&lt;&#x2F;span&gt;&lt;span&gt;]
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub trait &lt;&#x2F;span&gt;&lt;span&gt;EventAction&amp;lt;E&amp;gt;: Send + Sync {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;on_start&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;on_stop&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;);
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    async &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;on_receive&lt;&#x2F;span&gt;&lt;span&gt;(
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;event&lt;&#x2F;span&gt;&lt;span&gt;: E,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;tx_event&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;mpsc::Sender&amp;lt;E&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;        &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;rx_event&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;mpsc::Receiver&amp;lt;E&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    ) -&amp;gt; Result&amp;lt;()&amp;gt;;
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;fn &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;on_error&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;self&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;error&lt;&#x2F;span&gt;&lt;span&gt;: BallistaError);
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;事件循环在启动时，会创建一个多生产者单消费者的有界事件队列，并启动一个异步任务去不断轮询事件队列消费端，直至收到 stop 信号&lt;&#x2F;li&gt;
&lt;li&gt;事件均通过生产者往队列发送&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;一个 SQL 执行中的事件驱动过程&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;ballista-mvp-part3&#x2F;.&#x2F;ballista-mvp-eventloop.drawio.png&quot; alt=&quot;ballista-mvp-eventloop&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;当接收到 Client 提交的 SQL 时，生成逻辑计划并发送 JobQueued 事件&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobQueued 事件后，基于逻辑计划生成单机执行计划，然后再生成分布式执行计划
&lt;ul&gt;
&lt;li&gt;如果分布式执行计划生成成功，存入共享 kv 中，发送 JobSubmitted 事件&lt;&#x2F;li&gt;
&lt;li&gt;如果分布式执行计划生成失败，则发送 JobPlanningFailed 事件&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobPlanningFailed 事件时，修改 job 状态为失败&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobSubmitted 事件时，发送 ReviveOffers 事件&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 ReviveOffers 事件时，遍历所有正在执行中的 job，生成 task 并发送给 Executor 集群&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 Executor 发送的任务状态更新时，发送 TaskUpdating 事件&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 TaskUpdating 事件时，释放集群计算资源，更新整个分布式执行计划的 stage 状态（Running -&amp;gt; Successful, Unresolved -&amp;gt; Resolved等），并发送 ReviveOffers 事件
&lt;ul&gt;
&lt;li&gt;如果有 stage 从 Unsolved 状态变更为 Resolved 状态，则发送 JobUpdated 事件&lt;&#x2F;li&gt;
&lt;li&gt;如果有 stage 执行失败，则修改 job 状态为失败，并发送 JobRunningFailed 事件&lt;&#x2F;li&gt;
&lt;li&gt;如果所有 stage 均执行成功，则修改 job 状态为成功，并发送 JobFinished 事件&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobUpdated 事件时，更新共享 kv 中分布式执行计划&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobRunningFailed 事件时，更新共享 kv 中分布式执行计划，发送 CancelTasks 事件，向 Executor 集群发送清除 job 中间执行结果的请求，然后一段时间后从共享 kv 中移除该 job&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 CancelTasks 事件时，向 Executor 集群发送取消 task 执行的请求&lt;&#x2F;li&gt;
&lt;li&gt;当接收到 JobFinished 事件时，更新共享 kv 中分布式执行计划，一段时间后向 Executor 集群发送清除 job 中间执行结果的请求，然后从共享 kv 中移除该 job&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ballista 分布式查询引擎 - 分布式执行计划</title>
		<published>2024-04-20T00:00:00+00:00</published>
		<updated>2024-04-20T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/ballista-mvp-part2/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/ballista-mvp-part2/</id>
		<content type="html">&lt;h2 id=&quot;sheng-cheng-fen-bu-shi-zhi-xing-ji-hua&quot;&gt;生成分布式执行计划&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;原始 SQL&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-sql &quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;SELECT &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;customer&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;c_custkey&lt;&#x2F;span&gt;&lt;span&gt;, &lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;sum&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;orders&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;o_totalprice&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;as&lt;&#x2F;span&gt;&lt;span&gt; total_amount 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;FROM&lt;&#x2F;span&gt;&lt;span&gt; customer &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;JOIN&lt;&#x2F;span&gt;&lt;span&gt; orders ON &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;customer&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;c_custkey &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;orders&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;o_custkey 
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;GROUP BY &lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;customer&lt;&#x2F;span&gt;&lt;span&gt;.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;c_custkey&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;注：customer 和 orders 两张表数据各分为 3 个 parquet 文件存储。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;使用 Datafusion 生成单机执行计划&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;ProjectionExec: expr=[c_custkey@0 as c_custkey, SUM(orders.o_totalprice)@1 as total_amount]
&lt;&#x2F;span&gt;&lt;span&gt;  AggregateExec: mode=SinglePartitioned, gby=[c_custkey@0 as c_custkey], aggr=[SUM(orders.o_totalprice)]
&lt;&#x2F;span&gt;&lt;span&gt;    ProjectionExec: expr=[c_custkey@0 as c_custkey, o_totalprice@2 as o_totalprice]
&lt;&#x2F;span&gt;&lt;span&gt;      HashJoinExec: mode=Partitioned, join_type=Inner, on=[(c_custkey@0, o_custkey@0)]
&lt;&#x2F;span&gt;&lt;span&gt;        RepartitionExec: partitioning=Hash([c_custkey@0], 16), input_partitions=16
&lt;&#x2F;span&gt;&lt;span&gt;          RepartitionExec: partitioning=RoundRobinBatch(16), input_partitions=3
&lt;&#x2F;span&gt;&lt;span&gt;            ParquetExec: file_groups={3 groups: [...]}, projection=[c_custkey]
&lt;&#x2F;span&gt;&lt;span&gt;        RepartitionExec: partitioning=Hash([o_custkey@0], 16), input_partitions=16
&lt;&#x2F;span&gt;&lt;span&gt;          RepartitionExec: partitioning=RoundRobinBatch(16), input_partitions=3
&lt;&#x2F;span&gt;&lt;span&gt;            ParquetExec: file_groups={3 groups: [...]}, projection=[o_custkey, o_totalprice]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;为什么会生成这样的单机执行计划？&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Datafusion 提供了 target_partitions 配置项（默认为本机的 CPU 核心数量）来配置并行度，在生成单机执行计划时会插入 RepartitionExec 算子来调整 partition 数量。由于表数据分布在 3 个 parquet 文件，
ParquetExec 读取后输出 3 个 partition，因此在这里插入 RepartitionExec 算子将 partition 数量从 3 个提高到 16 个。（在分布式环境下为了利用多个机器，支持更高的并行度，Ballista 提供了可以给每个 session 手动配置此项的支持）&lt;&#x2F;li&gt;
&lt;li&gt;Datafusion 提供了 repartition_joins 开关项，基于 join key 进行 hash repartition 后可并行执行 hash join。&lt;&#x2F;li&gt;
&lt;li&gt;这里其实还有优化空间，两个连续的 RepartitionExec 算子可以合并成一个（见 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&#x2F;issues&#x2F;9370&quot;&gt;issue-9370&lt;&#x2F;a&gt;）。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;生成初步的分布式执行计划&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;=========ResolvedStage[stage_id=1.0, partitions=3]=========
&lt;&#x2F;span&gt;&lt;span&gt;ShuffleWriterExec: Some(Hash([Column { name: &amp;quot;c_custkey&amp;quot;, index: 0 }], 16))
&lt;&#x2F;span&gt;&lt;span&gt;  ParquetExec: file_groups={3 groups: [...]}, projection=[c_custkey]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;=========ResolvedStage[stage_id=2.0, partitions=3]=========
&lt;&#x2F;span&gt;&lt;span&gt;ShuffleWriterExec: Some(Hash([Column { name: &amp;quot;o_custkey&amp;quot;, index: 0 }], 16))
&lt;&#x2F;span&gt;&lt;span&gt;  ParquetExec: file_groups={3 groups: [...]}, projection=[o_custkey, o_totalprice]
&lt;&#x2F;span&gt;&lt;span&gt;
&lt;&#x2F;span&gt;&lt;span&gt;=========UnResolvedStage[stage_id=3.0, children=2]=========
&lt;&#x2F;span&gt;&lt;span&gt;ShuffleWriterExec: None
&lt;&#x2F;span&gt;&lt;span&gt;  ProjectionExec: expr=[c_custkey@0 as c_custkey, SUM(orders.o_totalprice)@1 as total_amount]
&lt;&#x2F;span&gt;&lt;span&gt;    AggregateExec: mode=SinglePartitioned, gby=[c_custkey@0 as c_custkey], aggr=[SUM(orders.o_totalprice)]
&lt;&#x2F;span&gt;&lt;span&gt;      ProjectionExec: expr=[c_custkey@0 as c_custkey, o_totalprice@2 as o_totalprice]
&lt;&#x2F;span&gt;&lt;span&gt;        HashJoinExec: mode=Partitioned, join_type=Inner, on=[(c_custkey@0, o_custkey@0)]
&lt;&#x2F;span&gt;&lt;span&gt;          UnresolvedShuffleExec
&lt;&#x2F;span&gt;&lt;span&gt;          UnresolvedShuffleExec
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;ResolvedStage 代表当前 stage 可以立即执行，UnResolvedStage 代表当前 stage 依赖的前置 stage 还没执行完毕。&lt;&#x2F;li&gt;
&lt;li&gt;join 的两个子树因为执行了 repartition 操作，因此会生成两个 stage：stage1 和 stage2。&lt;&#x2F;li&gt;
&lt;li&gt;最终会在树的 root 那里再生成一个 stage：stage3，它依赖 stage1 和 stage2。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;在 stage1 和 stage2 执行完毕后，stage3 会更新成如下&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;ShuffleWriterExec: None
&lt;&#x2F;span&gt;&lt;span&gt;  ProjectionExec: expr=[c_custkey@0 as c_custkey, SUM(orders.o_totalprice)@1 as total_amount]
&lt;&#x2F;span&gt;&lt;span&gt;    AggregateExec: mode=SinglePartitioned, gby=[c_custkey@0 as c_custkey], aggr=[SUM(orders.o_totalprice)]
&lt;&#x2F;span&gt;&lt;span&gt;      ProjectionExec: expr=[c_custkey@0 as c_custkey, o_totalprice@2 as o_totalprice]
&lt;&#x2F;span&gt;&lt;span&gt;        HashJoinExec: mode=Partitioned, join_type=Inner, on=[(c_custkey@0, o_custkey@0)]
&lt;&#x2F;span&gt;&lt;span&gt;          ShuffleReaderExec: partitions=16
&lt;&#x2F;span&gt;&lt;span&gt;          ShuffleReaderExec: partitions=16
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;UnsolvedShuffleExec 会被 ShuffleReaderExec 算子替代。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;最终的分布式执行计划&lt;&#x2F;strong&gt;
&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;ballista-mvp-part2&#x2F;.&#x2F;ballista-mvp-dag.drawio.png&quot; alt=&quot;ballista-mvp-dag&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;为什么会生成这样的分布式执行计划？&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Ballista 会在执行 repartition 的算子（如 RepartitionExec&#x2F;CoalescePartitionsExec&#x2F;SortPreservingMergeExec 算子，也被称为 pipeline breaker）那里插入 shuffle 算子，将单机执行计划分割成多个 stage，每个 stage 内部所有算子均为相同的分区方案。&lt;&#x2F;li&gt;
&lt;li&gt;每个 stage 最终都会通过 ShuffleWriterExec 算子对执行结果 repartition （如有需要）并写入本地磁盘。&lt;&#x2F;li&gt;
&lt;li&gt;每个有前置依赖的 stage 都会从 ShuffleReaderExec 算子开始执行，ShuffleReaderExec 算子负责读取前置 stage 产生的中间执行结果。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shuffle-suan-zi&quot;&gt;Shuffle 算子&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;ShuffleWriterExec 算子&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ShuffleWriterExec {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 所属 job (即 query)，全局唯一
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;job_id&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; stage id，job 内唯一
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stage_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; stage 执行计划
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;plan&lt;&#x2F;span&gt;&lt;span&gt;: Arc&amp;lt;dyn ExecutionPlan&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 中间结果写入磁盘目录
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;work_dir&lt;&#x2F;span&gt;&lt;span&gt;: String,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 输出的 partition 方案，空则代表不做 repartition
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;shuffle_output_partitioning&lt;&#x2F;span&gt;&lt;span&gt;: Option&amp;lt;Partitioning&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 执行过程中的指标
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;metrics&lt;&#x2F;span&gt;&lt;span&gt;: ExecutionPlanMetricsSet,
&lt;&#x2F;span&gt;&lt;span&gt;}  
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;work_dir 在生成分布式执行计划时为空，等到实际执行时，会被替换为 Executor 的 work_dir。&lt;&#x2F;li&gt;
&lt;li&gt;最终每个 stage 输出的每个 partition 数据以 Arrow IPC 格式存储
&lt;ul&gt;
&lt;li&gt;当 ShuffleWriterExec 不做 repartition 时，数据存储在 &lt;code&gt;&amp;lt;work_dir&amp;gt;&#x2F;&amp;lt;job_id&amp;gt;&#x2F;&amp;lt;stage_id&amp;gt;&#x2F;&amp;lt;partition&amp;gt;&#x2F;data.arrow&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;当 ShuffleWriterExec 需要 repartition 时，数据存储在 &lt;code&gt;&amp;lt;work_dir&amp;gt;&#x2F;&amp;lt;job_id&amp;gt;&#x2F;&amp;lt;stage_id&amp;gt;&#x2F;&amp;lt;output_partition&amp;gt;&#x2F;data-&amp;lt;input_partition&amp;gt;.arrow&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;ShuffleReaderExec 算子&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub struct &lt;&#x2F;span&gt;&lt;span&gt;ShuffleReaderExec {
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 需要读取的 stage id
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;stage_id&lt;&#x2F;span&gt;&lt;span&gt;: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;usize&lt;&#x2F;span&gt;&lt;span&gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 输出的 schema
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub&lt;&#x2F;span&gt;&lt;span&gt;(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;crate&lt;&#x2F;span&gt;&lt;span&gt;) &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;schema&lt;&#x2F;span&gt;&lt;span&gt;: SchemaRef,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 每个 partition 可以从多个位置读取
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;pub &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;partition&lt;&#x2F;span&gt;&lt;span&gt;: Vec&amp;lt;Vec&amp;lt;PartitionLocation&amp;gt;&amp;gt;,
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a0a1a7;&quot;&gt;&#x2F;&#x2F;&#x2F; 执行过程中的指标
&lt;&#x2F;span&gt;&lt;span&gt;    &lt;&#x2F;span&gt;&lt;span style=&quot;color:#e45649;&quot;&gt;metrics&lt;&#x2F;span&gt;&lt;span&gt;: ExecutionPlanMetricsSet,
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ol&gt;
&lt;li&gt;对于 partition 数据在本地的，直接从本地磁盘读取&lt;&#x2F;li&gt;
&lt;li&gt;对于 partition 数据在其他 Executor 上的，通过 Flight 协议流式读取&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;UnresolvedShuffleExec 算子&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;pub struct UnresolvedShuffleExec {
&lt;&#x2F;span&gt;&lt;span&gt;    pub stage_id: usize,
&lt;&#x2F;span&gt;&lt;span&gt;    pub schema: SchemaRef,
&lt;&#x2F;span&gt;&lt;span&gt;    pub output_partition_count: usize,
&lt;&#x2F;span&gt;&lt;span&gt;}  
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;主要起到占位符作用，等前置 stage 执行完毕后，UnresolvedShuffleExec 算子会被实际的 ShuffleReaderExec 算子替换。&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Ballista 分布式查询引擎 - 架构总览</title>
		<published>2024-04-17T00:00:00+00:00</published>
		<updated>2024-04-17T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/ballista-mvp-part1/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/ballista-mvp-part1/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-ballista&quot;&gt;Ballista&lt;&#x2F;a&gt; 是使用 Rust 编写的，基于 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow-rs&quot;&gt;Arrow&lt;&#x2F;a&gt; 内存数据格式、&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion&quot;&gt;Datafusion&lt;&#x2F;a&gt; 单机查询引擎和 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;arrow-rs&#x2F;tree&#x2F;master&#x2F;arrow-flight&quot;&gt;Flight SQL&lt;&#x2F;a&gt; 网络协议实现的类似 Spark SQL 的分布式查询引擎。&lt;&#x2F;p&gt;
&lt;p&gt;本系列主要基于 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;systemxlabs&#x2F;ballista-mvp&quot;&gt;ballista-mvp&lt;&#x2F;a&gt; 项目，它是从 &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;apache&#x2F;datafusion-ballista&quot;&gt;Ballista&lt;&#x2F;a&gt; 项目裁剪而来，保留其最小核心实现，方便学习，基于它来分析如何构建一个分布式查询引擎。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;ballista-mvp-part1&#x2F;.&#x2F;ballista-mvp-architecture.drawio.png&quot; alt=&quot;ballista-mvp-architecture&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Scheduler 集群&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;支持 Arrow Flight SQL 协议和 REST API&lt;&#x2F;li&gt;
&lt;li&gt;负责将原始 SQL 转换为分布式查询计划&lt;&#x2F;li&gt;
&lt;li&gt;负责调度整个分布式查询计划&lt;&#x2F;li&gt;
&lt;li&gt;将集群和作业状态存入共享 kv（如 etcd）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Executor 集群&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;支持 Arrow Flight 协议&lt;&#x2F;li&gt;
&lt;li&gt;负责查询计划执行&lt;&#x2F;li&gt;
&lt;li&gt;将中间结果写入本地磁盘&lt;&#x2F;li&gt;
&lt;li&gt;从共享文件系统或对象存储中读取数据集&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;一条 SQL 执行流程&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Client 通过 Flight SQL 协议连接到 Scheduler 并发送原始 SQL&lt;&#x2F;li&gt;
&lt;li&gt;Scheduler 使用 Datafusion 查询引擎来生成单机的执行计划&lt;&#x2F;li&gt;
&lt;li&gt;Scheduler 将单机执行计划拆分成多个 stage 的 DAG 执行图，每个 stage 可以被独立调度执行&lt;&#x2F;li&gt;
&lt;li&gt;Scheduler 生成 Task（job-stage-partition）通过 protobuf 序列化后发送到 Executor 集群并行执行&lt;&#x2F;li&gt;
&lt;li&gt;Executor 接收 Task 并执行，并将中间执行结果写入本地磁盘（供后续 stage 读取），并通知 Scheduler Task 执行状态&lt;&#x2F;li&gt;
&lt;li&gt;Scheduler 接收 Task 执行状态后，调度后续 stage 直至整个 DAG 图执行完毕&lt;&#x2F;li&gt;
&lt;li&gt;Scheduler 返回 SQL 执行结果给 Client&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>数据库系统架构论文</title>
		<published>2024-03-26T00:00:00+00:00</published>
		<updated>2024-03-26T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/architecture-of-a-database-system-paper/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/architecture-of-a-database-system-paper/</id>
		<content type="html">&lt;p&gt;&lt;a href=&quot;.&#x2F;architecture-of-a-database-system.pdf&quot;&gt;论文&lt;&#x2F;a&gt; | &lt;a href=&quot;.&#x2F;architecture-of-a-database-system-chinese.pdf&quot;&gt;中文翻译&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;dbms-zhu-yao-zu-jian&quot;&gt;DBMS 主要组件&lt;&#x2F;h2&gt;
&lt;img src=&quot;main-components-of-dbms.png&quot; alt=&quot;main-components-of-dbms&quot; width=&quot;600&quot;&#x2F;&gt;
&lt;p&gt;注：Process Manager 并非单指分配进程，而是根据 DBMS 实际实现的进程模型，分配进程或线程。Admission Control 指是否立即处理该查询，或是等待系统有足够资源时再处理。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;jin-cheng-mo-xing&quot;&gt;进程模型&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;mei-ge-dbms-worker-yi-ge-jin-cheng&quot;&gt;每个 DBMS Worker 一个进程&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：可移植性好（早期的 OS 对线程支持较差），可以利用 OS 保护措施&lt;&#x2F;li&gt;
&lt;li&gt;缺点：进程切换代价更大&lt;&#x2F;li&gt;
&lt;li&gt;案例：DB2，PostgreSQL，Oracle&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;mei-ge-dbms-worker-yi-ge-xian-cheng&quot;&gt;每个 DBMS Worker 一个线程&lt;&#x2F;h3&gt;
&lt;p&gt;线程又可分为 OS线程 或 DBMS 线程（轻量级线程，仅在用户空间调度而没有内核调度程序的参与）。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;优点：线程切换代价较小，共享数据友好&lt;&#x2F;li&gt;
&lt;li&gt;缺点：OS 对线程不提供溢出和指针的保护，调试困难，可移植性较差（在当时）&lt;&#x2F;li&gt;
&lt;li&gt;案例：DB2，SQL Server，MySQL&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;jin-cheng-xian-cheng-chi&quot;&gt;进程&#x2F;线程池&lt;&#x2F;h3&gt;
&lt;p&gt;由中央进程&#x2F;线程控制所有客户端连接，由进程&#x2F;线程池管理所有 DBMS worker。大小可动态变化。&lt;&#x2F;p&gt;
&lt;p&gt;DBMS worker 之间会共享数据&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;磁盘缓冲池（buffer pool）&lt;&#x2F;li&gt;
&lt;li&gt;锁表&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;DBMS 可能支持多种进程模型，比如 DB2 支持以上四种，Oracle 在 Windows 系统上采用多线程模型。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;准入控制&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;通过调度进程&#x2F;线程来确保客户端连接数在一个临界值以下&lt;&#x2F;li&gt;
&lt;li&gt;在查询语句转换和优化后的执行阶段，通过分析查询所需资源来决定是否推迟查询执行&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;bing-xing-jia-gou&quot;&gt;并行架构&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;gong-xiang-nei-cun-shared-memory&quot;&gt;共享内存（Shared-Memory）&lt;&#x2F;h3&gt;
&lt;img src=&quot;shared-memory-architecture.png&quot; alt=&quot;shared-memory-architecture&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;p&gt;在共享内存机器，OS 通常支持作业（进程或线程）被透明地分配到每个处理器上，并且共享的数据结构可以继续被所有作业所访问，所以上面四种进程模型可以运行良好。主要需要修改查询执行层，将单一的 SQL 并行到多个处理器上。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wu-gong-xiang-shared-nothing&quot;&gt;无共享（Shared-Nothing）&lt;&#x2F;h3&gt;
&lt;img src=&quot;shared-nothing-architecture.png&quot; alt=&quot;shared-nothing-architecture&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;p&gt;通过网络互联通信。表数据被水平分区到不同机器，对于每个 SQL 请求，会被发送到集群其他成员，然后各自并行执行查询本地所保存的数据。事务实现较复杂。可扩展性强。需要冗余数据来提高可用性。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gong-xiang-ci-pan-shared-disk&quot;&gt;共享磁盘（Shared-Disk）&lt;&#x2F;h3&gt;
&lt;img src=&quot;shared-disk-architecture.png&quot; alt=&quot;shared-disk-architecture&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;p&gt;单个 DBMS 执行节点发生故障不会影响其他节点访问整个数据库。需要手动协调多个节点的共享数据（分布式锁，分布式缓冲池）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;numa-non-uniform-memory-access&quot;&gt;NUMA（Non-Uniform Memory Access）&lt;&#x2F;h3&gt;
&lt;img src=&quot;numa-architecture.png&quot; alt=&quot;numa-architecture&quot; width=&quot;400&quot;&#x2F;&gt;
&lt;p&gt;处理器访问本地内存比远程内存更快。NUMA 允许共享内存系统扩展到更多数量处理器的规模。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-xi-cha-xun-chu-li-qi&quot;&gt;关系查询处理器&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;cha-xun-jie-xi&quot;&gt;查询解析&lt;&#x2F;h3&gt;
&lt;p&gt;检查语法、引用、权限等，将 SQL 转换为内部形式（逻辑计划）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cha-xun-zhong-xie&quot;&gt;查询重写&lt;&#x2F;h3&gt;
&lt;p&gt;简化和标准化查询。例如&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;视图重写&lt;&#x2F;li&gt;
&lt;li&gt;简化常量表达式（&lt;code&gt;t.a &amp;lt; 10 + 2 + t.b&lt;&#x2F;code&gt;  =&amp;gt;  &lt;code&gt;t.a &amp;lt; 12 + t.b&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;谓词逻辑重写（&lt;code&gt;t.a &amp;lt; 10 and t.a &amp;gt; 20&lt;&#x2F;code&gt;  =&amp;gt;  &lt;code&gt;false&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;li&gt;语义优化（&lt;code&gt;select t1.a from t1, t2 where t1.b = t2.b&lt;&#x2F;code&gt; 且 &lt;code&gt;外键约束把 t1.b 绑定到 t2.b&lt;&#x2F;code&gt;  =&amp;gt;  &lt;code&gt;select t1.a from t1&lt;&#x2F;code&gt;）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;cha-xun-you-hua&quot;&gt;查询优化&lt;&#x2F;h3&gt;
&lt;p&gt;将查询内部表示形式（逻辑计划）转化为一个高效的执行计划（物理计划）。涉及&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;计划空间&lt;&#x2F;li&gt;
&lt;li&gt;选择率估算（直方图）&lt;&#x2F;li&gt;
&lt;li&gt;搜索算法（动态规划&#x2F;级联搜索）&lt;&#x2F;li&gt;
&lt;li&gt;并行（两阶段方案：先生成单机执行计划，再转换为分布式执行计划。单阶段方案则直接生成分布式执行计划）&lt;&#x2F;li&gt;
&lt;li&gt;自动调优（如 learning optimizer）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;cha-xun-zhi-xing&quot;&gt;查询执行&lt;&#x2F;h3&gt;
&lt;p&gt;迭代器模型&lt;&#x2F;p&gt;
&lt;pre style=&quot;background-color:#fafafa;color:#383a42;&quot;&gt;&lt;code&gt;&lt;span&gt;class iterator {
&lt;&#x2F;span&gt;&lt;span&gt;    iterator &amp;amp;inputs[];
&lt;&#x2F;span&gt;&lt;span&gt;    void init();
&lt;&#x2F;span&gt;&lt;span&gt;    tuple get_next();
&lt;&#x2F;span&gt;&lt;span&gt;    void close();
&lt;&#x2F;span&gt;&lt;span&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;可以通过引入 Exchange 算子来实现并行。&lt;&#x2F;p&gt;
&lt;p&gt;迭代器中元组可以是&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;缓冲池中元组的引用（需要 pin 住所在页）&lt;&#x2F;li&gt;
&lt;li&gt;从缓冲池中复制一份&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;索引引用行&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;使用物理地址 RID（例如 page id + slot num），只支持二级索引（非聚簇索引，减少聚簇索引 B+ 树分裂导致频繁的行移动）。速度快，但行移动开销大&lt;&#x2F;li&gt;
&lt;li&gt;使用主键。支持聚簇索引和二级索引，但二级索引回表会牺牲一些性能&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;数据仓库特点&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;位图索引，min-max索引，布隆过滤&lt;&#x2F;li&gt;
&lt;li&gt;需要快速批量导入数据&lt;&#x2F;li&gt;
&lt;li&gt;物化视图（可以查询的实际表）&lt;&#x2F;li&gt;
&lt;li&gt;重点优化基于雪花模型的聚合查询&lt;&#x2F;li&gt;
&lt;li&gt;列存&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;cun-chu-guan-li&quot;&gt;存储管理&lt;&#x2F;h2&gt;
&lt;p&gt;主要有两种基本类型的存储管理器&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;DBMS 直接和底层磁盘驱动交互&lt;&#x2F;li&gt;
&lt;li&gt;DBMS 使用标准 OS 文件系统&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;主要从两方面优化&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;空间：物理存储上的临近性（顺序读写），创建大文件&lt;&#x2F;li&gt;
&lt;li&gt;时间：缓冲池替代 OS IO 缓冲机制（预读取，确保 WAL 落盘，双缓冲导致内存拷贝消耗）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;shi-wu&quot;&gt;事务&lt;&#x2F;h2&gt;
&lt;p&gt;ACID&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：全做或全不做&lt;&#x2F;li&gt;
&lt;li&gt;一致性：满足完整性约束&lt;&#x2F;li&gt;
&lt;li&gt;隔离性：从应用开发者视角来看事务是隔离的，互不影响&lt;&#x2F;li&gt;
&lt;li&gt;持久性：出现故障不会丢失更新&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;三种主要的并发控制技术&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;严格两阶段锁（2PL）：读数据需读锁，写数据需排他锁。事务拥有的锁在事务结束时释放&lt;&#x2F;li&gt;
&lt;li&gt;多版本并发控制（MVCC）：为过去某一时间点的数据状态保存副本&lt;&#x2F;li&gt;
&lt;li&gt;乐观并发控制（OCC）：事务提交时检测读写历史来判断是否冲突，冲突则回滚&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;为减少锁请求和冲突，很多 DBMS 将 MVCC 或 OCC 作为 2PL 的一个补充。&lt;&#x2F;p&gt;
&lt;p&gt;事务隔离级别&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;读未提交：事务可以读任何已提交或未提交的数据（读操作不加锁）&lt;&#x2F;li&gt;
&lt;li&gt;读已提交：事务可以读任何已提交的数据（读操作加锁，读完立即释放）&lt;&#x2F;li&gt;
&lt;li&gt;可重复读：事务只能读取一个已提交数据的一个版本（读操作加上，事务结束释放）&lt;&#x2F;li&gt;
&lt;li&gt;串行化&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;除了 ANSI SQL 定义的隔离级别外，还有其他的隔离级别：游标稳定，快照隔离，读一致。&lt;&#x2F;p&gt;
&lt;p&gt;数据库标准恢复机制采用 WAL 日志，为优化性能&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;采用 DIRECT, STEAL&#x2F;NOT-FORCE 模式运行
&lt;ol&gt;
&lt;li&gt;数据项原地更新&lt;&#x2F;li&gt;
&lt;li&gt;事务未提交时，其修改的缓冲页可以被刷盘&lt;&#x2F;li&gt;
&lt;li&gt;当事务提交时，缓冲池不必强制刷盘&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;采用逻辑操作和物理操作混合的日志模式（逻辑日志用于撤销，物理日志用于重做）&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;索引 B+ 树并发控制&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Latch-coupling 方案（Crabing 协议）&lt;&#x2F;li&gt;
&lt;li&gt;Right-link 方案&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;解决幻读&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;谓词锁：锁定原始查询谓词所表示的逻辑区域（代价高）&lt;&#x2F;li&gt;
&lt;li&gt;next-key 锁
&lt;ol&gt;
&lt;li&gt;索引插入操作需要为大于其 key 的下一个元组分配排他锁&lt;&#x2F;li&gt;
&lt;li&gt;读事务需要为下一个元组添加共享锁&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;gong-xiang-zu-jian&quot;&gt;共享组件&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;目录管理器
&lt;ul&gt;
&lt;li&gt;管理元数据（用户&#x2F;数据库&#x2F;表&#x2F;列&#x2F;索引等），元数据以表形式存储在数据库中&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;内存分配器&lt;&#x2F;li&gt;
&lt;li&gt;磁盘管理器&lt;&#x2F;li&gt;
&lt;li&gt;备份服务
&lt;ul&gt;
&lt;li&gt;物理备份&lt;&#x2F;li&gt;
&lt;li&gt;基于触发器的备份&lt;&#x2F;li&gt;
&lt;li&gt;基于日志的备份&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;管理、监控和工具&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Rust 切片</title>
		<published>2024-03-23T00:00:00+00:00</published>
		<updated>2024-03-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/rust-slice/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/rust-slice/</id>
		<content type="html">&lt;h2 id=&quot;qie-pian-ding-yi&quot;&gt;切片定义&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;切片是一种动态大小类型，表示 T 类型元素序列的“视图”。切片类型被写作 &lt;code&gt;[T]&lt;&#x2F;code&gt;。&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;p&gt;切片主要通过指针类型来使用&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt;：共享切片，经常被直接称作切片（对指向数据的不可变借用）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;mut [T]&lt;&#x2F;code&gt;：可变切片（对指向数据的可变借用）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;Box&amp;lt;[T]&amp;gt;&lt;&#x2F;code&gt;：boxed 切片，拥有其所有权&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;img src=&quot;https:&#x2F;&#x2F;systemxlabs.github.io&#x2F;blog&#x2F;rust-slice&#x2F;rust-container-cheat-sheet.png&quot; alt=&quot;rust-container-cheat-sheet&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qie-pian-t-yu-shu-zu-t-n-bi-jiao&quot;&gt;切片 &lt;code&gt;[T]&lt;&#x2F;code&gt; 与数组 &lt;code&gt;[T; N]&lt;&#x2F;code&gt; 比较&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;类型：&lt;code&gt;[T]&lt;&#x2F;code&gt; 是切片类型；&lt;code&gt;[T; N]&lt;&#x2F;code&gt; 是数组类型，且 &lt;code&gt;[T; 2]&lt;&#x2F;code&gt; 和 &lt;code&gt;[T; 3]&lt;&#x2F;code&gt; 是不同的数组类型&lt;&#x2F;li&gt;
&lt;li&gt;编译期大小：&lt;code&gt;[T]&lt;&#x2F;code&gt; 是编译期未知大小（DST），而 &lt;code&gt;[T; N]&lt;&#x2F;code&gt; 是编译期已知大小的&lt;&#x2F;li&gt;
&lt;li&gt;容量均不可变： &lt;code&gt;[T]&lt;&#x2F;code&gt; 与 &lt;code&gt;[T; N]&lt;&#x2F;code&gt; 可以改变元素内容，但容量不可变&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h2 id=&quot;qie-pian-yin-yong-t-mut-t-yu-pu-tong-yin-yong-t-de-qu-bie&quot;&gt;切片引用 &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;&amp;amp;mut [T]&lt;&#x2F;code&gt; 与普通引用 &lt;code&gt;&amp;amp;T&lt;&#x2F;code&gt; 的区别&lt;&#x2F;h2&gt;
&lt;p&gt;切片引用是一个双字值的胖指针，包含指针和长度；而普通引用只包含指针。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; pointer_size &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;std::mem::size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;u8&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;();
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(pointer_size, std::mem::size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;String&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; pointer_size, std::mem::size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; pointer_size, std::mem::size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; pointer_size, std::mem::size_of::&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*const &lt;&#x2F;span&gt;&lt;span&gt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; pointer_size, std::mem::size_of::&amp;lt;Box&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;span&gt;assert_eq!(&lt;&#x2F;span&gt;&lt;span style=&quot;color:#c18401;&quot;&gt;2 &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;*&lt;&#x2F;span&gt;&lt;span&gt; pointer_size, std::mem::size_of::&amp;lt;Rc&amp;lt;[&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;u8&lt;&#x2F;span&gt;&lt;span&gt;]&amp;gt;&amp;gt;());
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;zi-fu-chuan-qie-pian-str&quot;&gt;字符串切片 &lt;code&gt;str&lt;&#x2F;code&gt;&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;code&gt;str&lt;&#x2F;code&gt; 类似 &lt;code&gt;[u8]&lt;&#x2F;code&gt; ，只不过 &lt;code&gt;str&lt;&#x2F;code&gt; 需要保证里面的字节内容是 UTF-8 编码的。&lt;&#x2F;p&gt;
&lt;p&gt;str 不仅指存放在程序只读区域的字面量，也可以指存放在堆上的字符串。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;rust&quot; style=&quot;background-color:#fafafa;color:#383a42;&quot; class=&quot;language-rust &quot;&gt;&lt;code class=&quot;language-rust&quot; data-lang=&quot;rust&quot;&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s: &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;&amp;amp;str = &lt;&#x2F;span&gt;&lt;span style=&quot;color:#50a14f;&quot;&gt;&amp;quot;hello&amp;quot;&lt;&#x2F;span&gt;&lt;span&gt;;
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s: String &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;= &lt;&#x2F;span&gt;&lt;span&gt;String::from(s);
&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;let&lt;&#x2F;span&gt;&lt;span&gt; s: Box&amp;lt;&lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;str&lt;&#x2F;span&gt;&lt;span&gt;&amp;gt; &lt;&#x2F;span&gt;&lt;span style=&quot;color:#a626a4;&quot;&gt;=&lt;&#x2F;span&gt;&lt;span&gt; s.&lt;&#x2F;span&gt;&lt;span style=&quot;color:#0184bc;&quot;&gt;into_boxed_str&lt;&#x2F;span&gt;&lt;span&gt;();
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;在对字符串使用切片语法时需要格外小心，切片的索引必须落在字符之间的边界位置，也就是 UTF-8 字符的边界。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;qi-ta&quot;&gt;其他&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;数组和字符串的许多方法（如遍历、搜索、排序等）是在切片上定义的&lt;&#x2F;li&gt;
&lt;li&gt;通常优先使用切片类型 &lt;code&gt;&amp;amp;[T]&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;&amp;amp;str&lt;&#x2F;code&gt;，因为使用 &lt;code&gt;&amp;amp;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;&amp;amp;String&lt;&#x2F;code&gt; 会多一层跳转到 &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;&#x2F;code&gt; &#x2F; &lt;code&gt;String&lt;&#x2F;code&gt; 再调用其方法&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>ballista-mvp</title>
		<published>2024-03-23T00:00:00+00:00</published>
		<updated>2024-03-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/ballista-mvp/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/ballista-mvp/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>bustubx</title>
		<published>2024-03-22T00:00:00+00:00</published>
		<updated>2024-03-22T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/bustubx/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/bustubx/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>datafusion-geo</title>
		<published>2024-03-15T00:00:00+00:00</published>
		<updated>2024-03-15T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/datafusion-geo/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/datafusion-geo/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>derive-with</title>
		<published>2024-01-20T00:00:00+00:00</published>
		<updated>2024-01-20T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/derive-with/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/derive-with/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>sqlparser-nom</title>
		<published>2023-10-28T00:00:00+00:00</published>
		<updated>2023-10-28T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/sqlparser-nom/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/sqlparser-nom/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>databend-parser</title>
		<published>2023-09-20T00:00:00+00:00</published>
		<updated>2023-09-20T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/databend-parser/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/databend-parser/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>Raft 共识算法</title>
		<published>2023-03-28T00:00:00+00:00</published>
		<updated>2023-03-28T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/raft-consensus-algorithm/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/raft-consensus-algorithm/</id>
		<content type="html">&lt;p&gt;这是在小米工作时在组内做的一个分享。之前使用Rust语言实现过Raft共识算法，算是比较深入地了解过。&lt;&#x2F;p&gt;
&lt;img src=&quot;raft-logo.svg&quot; style=&quot;width:300px&quot; &#x2F;&gt;
&lt;p&gt;&lt;a href=&quot;raft-consensus-algorithm.pdf&quot;&gt;PDF地址&lt;&#x2F;a&gt;
&lt;br&#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lewiszlw&#x2F;raft&quot;&gt;项目地址&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>raft</title>
		<published>2023-02-23T00:00:00+00:00</published>
		<updated>2023-02-23T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/projects/raft/" type="text/html"/>
		<id>https://systemxlabs.github.io/projects/raft/</id>
		<content type="html"></content>
	</entry>
	<entry xml:lang="en">
		<title>实现 HTTP 服务器</title>
		<published>2022-07-12T00:00:00+00:00</published>
		<updated>2022-07-12T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/implement-httpd/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/implement-httpd/</id>
		<content type="html">&lt;p&gt;在复习C语言时，用C实现了一个微型HTTP服务器练手，同时也复习了相关网络协议。
&lt;img src=&quot;page1.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;implement-httpd.pdf&quot;&gt;PDF地址&lt;&#x2F;a&gt;
&lt;br&#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;lewiszlw&#x2F;tinyhttpd&quot;&gt;项目地址&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>分布式任务调度</title>
		<published>2021-12-01T00:00:00+00:00</published>
		<updated>2021-12-01T00:00:00+00:00</updated>
		<link rel="alternate" href="https://systemxlabs.github.io/blog/distributed-job-scheduling/" type="text/html"/>
		<id>https://systemxlabs.github.io/blog/distributed-job-scheduling/</id>
		<content type="html">&lt;p&gt;这是在小米工作时为智能外呼服务实现的分布式任务调度系统。调研了Quartz、XXL-JOB等开源调度系统，同时结合业务并发特点，最终设计出符合业务需要的调度系统。
&lt;img src=&quot;page1.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;img src=&quot;page2.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;img src=&quot;page3.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;img src=&quot;page4.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;img src=&quot;page5.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;
&lt;br&#x2F;&gt;
&lt;img src=&quot;page6.png&quot; style=&quot;width:800px&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
</feed>
